
// api2pages.js
// v0.0.4 - 3 May 2018 (Version history follows program code)
//
// A node.js program to support documention projects using
// Doxygen and Moxygen to generate reference pages in Markdown.
// Specifically, this file separates Moxygen's single API.MD
// file into separate topics, cleans up formatting changes,
// and rewrites links to reflect the new filenames.
//
// Note: This utility was created because the results of 
// the other tools needed changes for our publishing system.
// 
// 
// -- lance Leonard (lance.leonard@microsoft.com), 21 Feb 2018
//
// Use: node api2pages <filename>
//
// where <filename> is the Markdown file generated by moxygen
// from Doxygen XML data.
//


// To Do:
// 
// 1.  Review for clean-up and publish-ability.
// 2.  Re-do status reporting so that it can be logged 
// 3.  Currently requires the subdirectories to exist before running
//       the script; they should be created/configurable.
// 4.  Add a DEBUG option so that a) auto-log can be turned off
//       by default and b) LEVELS can be implemented.


// support functions

/**
 * Replaces a character sequence with a new one; 
 * used to remove extraneous formatting from a
 * line, typically a prototype.
 **/
function cleanupLine( strLineIn, strOld, strNew ) {

   var strResult = strLineIn;
   if ( strLineIn.indexOf( strOld ) > -1 ) {
        var aryTokens = strLineIn.split( strOld );
        strResult = aryTokens.join( strNew );
   }
   return strResult;

}

/**
 * Shortcut function for writing to the console.
 **/
function clog( oOutput ) {
   console.log( jStr( oOutput ) );
}

/**
 * Returns TRUE when parameter value is NOT blank;
 * used to filter arrays.
 **/
function elementHasValue( element ) {

  // Yes, I could've written this differently.  I 
  // think the intention is clearer this way and 
  // I expect the performance difference to be 
  // trivial.
  return isBlank( element ) ? false : true;

}

/**
 * Simple function to determine whether a value specifies an actual
 * (non-null) value. 
 **/
function isBlank( inputValue ) {

   var blnResult = ( ( inputValue == undefined ) ||
                     ( inputValue == null ) || 
                     ( inputValue == "" ) );
   return blnResult;

}

/**
 * Shortcut function to format JSON output.
 **/
function jStr( oInput ) {
   return JSON.stringify( oInput, undefined, 3 )
}


// void main() - program begins here

var fs = require( "fs" ),
    os = require( "os");
var strErrorMsg = "";  // assume everything's fine.

// TODO - Option handling needs to be beefed up and extended.
// Currently considering: -v (verbose), -d (debug) -c (config)
// Need to find/devise good option handling for node.  

var strFilename = process.argv[ 2 ];
if ( isBlank( strFilename ) ) {
   console.log( "Error: moxygen source not specified." );
   return
} else {

   // Load file into an array with each source line as a unique element.
   // Possible memory concerns with large APIs; should not be a problem in 
   // the short term.
   const k_h1Syntax = "# ";
   const k_NoDocsYet = "_Not documented yet._";

   var strInFile = fs.readFileSync( strFilename, 'utf-8' );
   var aryLines = strInFile.split( /[\r\n]+/ );
   var aNewPages = [];
   var iFileNo = -1;
   var blnSkipLine = false;  // should the current line be ignored?
   var aryAllDecls = [];

   var oLinkData = JSON.parse( fs.readFileSync( './linkconfig.json' ) );

   // STAGE 1: Import the moxygen output file...
   // Here, we separate the input moxygen file into separate topics _and_ 
   // perform limited clean-up. 
   // 
   // TODO: Add configuration abilities.  Longer term, make
   // clean up data driven, perhaps based on style fix-up engine 
   // in TOC generator.  

   clog( "Processing " + strFilename + "..." );
   for ( var xLines = 0; xLines < aryLines.length; xLines++ ) {

      var strThisLine = aryLines[ xLines ];
      // if this is a new file, make a place for it.
      if ( strThisLine.startsWith( k_h1Syntax ) ) {
         iFileNo++;
         aNewPages[ iFileNo ] = new Object();
         aNewPages[ iFileNo ].lines = [];
         aNewPages[ iFileNo ].declarations = [];

         var aryTokens = strThisLine.split( '::' );
         var strClassName = "<Classname not detected>";
         if ( aryTokens.length > 0 ) {
            strClassName = aryTokens[ ( aryTokens.length - 1 ) ];
         }
         aNewPages.classname = strClassName;
       }

      // Skip over code blocks at this time.  This approach ensures
      // we skip both ``` lines and the lines between.
      if ( strThisLine.startsWith( "```" ) ) {
         blnSkipLine = !( blnSkipLine );
         continue;
      }
      if (blnSkipLine) { continue; } 

      // Skip over the moxygen credit; sorry, folks.
      if ( strThisLine.startsWith( 
           "Generated by [Moxygen](https://sourcey.com/moxygen)" ) ) {
         continue;
      }

      // Skip over the two known uses of inline currently in the SDK.

      // this appears in /src/api/mip/rms/user_policy.h
      if ( ( strThisLine.indexOf( "inline") > -1 ) && 
           ( strThisLine.indexOf( "operator\\|" ) > -1 ) ) {
         continue;
      }

      // this appears in /src/api/mip/common_types.h
      if ( ( strThisLine.indexOf( "inline") > -1 ) && 
           ( strThisLine.indexOf( "GetAssignmentMethodName" ) > -1 ) ) {
         continue;
      }
      
      // If we get here, we've decided to keep the line.  Let's see if it's a 
      // Method summary and, if so, clean up the declaration.
      //
      // Moxygen currently hardcodes backticks and links into the prototype
      // it builds from doxygen data.  Sadly, I've not yet found a way to 
      // override this using its template system.  So we rip that stuff out, 
      // drop the bits we don't need, and rebuild the string for our needs.

      // Declaration line
      if ( strThisLine.startsWith( '`' ) ) {

         var intLastPipe = strThisLine.lastIndexOf( '|' );
         var strLineHelp = "";
         if ( intLastPipe > -1 ) {
            strLineHelp = strThisLine.substr( intLastPipe + 1 );
            strThisLine = strThisLine.substr( 0, intLastPipe );

            // Note: we need to kill the copyright notices
            if ( strLineHelp.indexOf(  "Copyright (c) Microsoft Corporation." ) > -1 ) {
               strLineHelp = "";
            }

            if ( strLineHelp.trim() == "" ) {
               strLineHelp = "_Not yet documented._";
            }
         }

         var intLinkOpen = -1;  // index of first link left bracket
         var intParamOpen = -1; // index of parameter left param
         var aryTokens = strThisLine.split( "`");   
         strThisLine = aryTokens.join( "" );

         var liLinkSepPos = strThisLine.indexOf( '](');

         // Remove all links in the prototype
         while ( liLinkSepPos > -1 ) {

            var liLinkBeg = strThisLine.indexOf( '[' );
            var liLinkEnd = strThisLine.indexOf( ')' );
            var liTitleEnd = strThisLine.indexOf( ']');

            var strTextLeft = strThisLine.substr( 0, liLinkBeg );
            var strTextTitle = strThisLine.substr( liLinkBeg + 1, ( liTitleEnd - liLinkBeg ) - 1 );
            var strTextRight = strThisLine.substr( liLinkEnd + 1);
            
            strThisLine = strTextLeft + strTextTitle + strTextRight;
            liLinkSepPos = strThisLine.indexOf( '](');

         }

         // The next several operations remove extraneous spaces from the prototype.
         // Use care when reviewing these, as it's easy to miss some of the more
         // subtle changes.  The order is intentional.

         // Remove spaces added by doxygen/moxygen/whoever
         strThisLine = cleanupLine( strThisLine, '< ', '<' );
         strNewLine = cleanupLine( strThisLine, ' >', '>' );

         // Yes, we're adding a space following the last closing angle bracket.
         var liLastBracket = strNewLine.lastIndexOf( '>' );
         strThisLine = strNewLine.substr( 0, liLastBracket + 1 ) + " " + strNewLine.substr( liLastBracket + 1);

         strThisLine = cleanupLine( strThisLine, ' * ', '* ');
         strThisLine = cleanupLine( strThisLine, ' *', '*' );
         strThisLine = cleanupLine( strThisLine, '  & ', '& ');
         strThisLine = cleanupLine( strThisLine, ' & ', '& ' );
         strThisLine = cleanupLine( strThisLine, ', ', ',' );
         strThisLine = cleanupLine( strThisLine, ',', ', ' );
         strThisLine = cleanupLine( strThisLine, '  ', ' ' );

         // Here, the declaration is reduced to something near to what it was
         // in the original file (save for bugs, like the extra "inline" tokens)
         var strThisDecl = strThisLine;

         // Since we're adding this line, let's record a declaration.
         var oNewDecl = new Object();
         
         // Extract the declaration name; note the bit of trickery with the
         // non-standard trimRight().
         var strDeclName = strThisDecl.trimRight();
         var liSpacePos = strDeclName.lastIndexOf( ' ' );
         var liOpenParen = strDeclName.indexOf( '(' );

         if ( liOpenParen == -1 ) {
            strDeclName = strDeclName.substr( liSpacePos + 1 );
         } else {
            liSpacePos = strDeclName.lastIndexOf( ' ', liOpenParen );
            strDeclName = strDeclName.substr( liSpacePos + 1, ( liOpenParen - liSpacePos ) - 1);
         }
         oNewDecl.declName = strDeclName;
         oNewDecl.declType = strThisDecl.substr( strThisDecl.indexOf( ' ' ) );
         
         // Finally, brute force remove 'inline' (Notice we run two checks,
         // one for a trailing space, one without.)
         // TODO: Refactor this to be less brute-forcey.
         var intPos = strThisDecl.indexOf( ' inline ' );
         if ( intPos > -1 ) {
            aryTokens = strThisDecl.split( ' inline ' );
            strThisDecl = aryTokens.join( ' ' );
         }
          
         // Some method lines are ending up with leading spaces.  Let's
         // nip those.
         if ( strThisLine.startsWith( ' ' ) ) {
            strThisLine = strThisLine.substr( 1 );
         }

         // Now that the declaration has been cleaned up, let's clean 
         // up the entire line.
         strThisLine = strThisDecl;
         if ( strLineHelp.length > 0 ) {
            strThisLine += " | " + strLineHelp;
         }
         
         oNewDecl.declaration = strThisDecl;
         aryAllDecls.push( strThisDecl );
         aNewPages[ iFileNo ].declarations.push( oNewDecl );

      }  // declaration

      // Here, we fix a moxygen rendering bug that appears when run 
      // against the SDK.  (The Methods section is incorrectly 
      // specified as an H4, rather than an H3.  
      //
      // Note that this also does two other things: it removes the 
      // annoying backticks and chops off the rest of the declaration
      // (which is why we're using an array, rather than substr).
      if ( strThisLine.startsWith( '#### `' ) ) {
         var strNewLine = strThisLine.substr( 1 );
         var aryTokens = strThisLine.split( "`");

         var intIndex = aryTokens.indexOf( '[' );
         strThisLine = "### " + aryTokens[ intIndex + 1 ];
      } 

      // Rip backticks out of the classname header
      if ( strThisLine.startsWith( '# class `' ) ||
           strThisLine.startsWith( '# struct `' ) ) {
         strThisLine = cleanupLine( strThisLine, '`', `` );
      }

      // Convert "#### Returns" sections to a token we'll 
      // later replace with the full line.
      if ( strThisLine == '#### Returns') {
         aNewPages[ iFileNo ].lines.push( "\n  " );
         strThisLine = "<Returns>";
      }

      // Convert "#### Parameters" sections to a paragraph. 
      if ( strThisLine == '#### Parameters') {
         strThisLine = "\nParameters:  ";
      }

      // Reformat parameter descriptions to fit our needs.
      if ( strThisLine.startsWith( '* `' ) ) {
         var aryTokens = strThisLine.split( '`' );
         if ( aryTokens.length > 0 ) {  // it almost always should be
            aryTokens[ 2 ] = ':' + aryTokens[ 2 ];
         }
         strThisLine = aryTokens.join( '**' );
      }

      // We're ready to add the line to the array data.  There's a 
      // bit more validation we need to do to make sure things are 
      // well structured.

      if ( strThisLine == "" ) {
         aNewPages[ iFileNo ].lines.push( os.EOL );
      } else {

         // If the current line in the file is an H3 and the new
         // new line is an H3, then we have a section with no
         // content.

         var liCurrentLine = aNewPages[ iFileNo ].lines.length;
         if ( liCurrentLine > 0 ) {

            var strLastLine = aNewPages[ iFileNo ].lines[ ( liCurrentLine - 1 ) ]; 
            if ( ( strLastLine.startsWith( "### " ) ) &&
                 ( strThisLine.startsWith( "### " ) ) ) {
                 aNewPages[ iFileNo ].lines.push( k_NoDocsYet + "\n" );
            }
         }

         // A variation on the previous test: If the new line starts
         // a new file, let's make sure the last line of the previous file 
         // doesn't end with a header
         if ( strThisLine.startsWith( '# ' ) ) {
           
            if ( iFileNo > 0 ) {
               var liLastLine = aNewPages[ iFileNo - 1 ].lines.length;
               var strLastLine = aNewPages[ iFileNo - 1 ].lines[ liLastLine - 1 ];
               if ( strLastLine.startsWith( "##" ) ) {
                  aNewPages[ iFileNo - 1 ].lines.push( k_NoDocsYet + "\n" );
               }
            }
         }

         // Make sure there's a line break before new sections
         if ( strThisLine.startsWith( "##" ) || 
              strThisLine.startsWith( '**See also**:' ) ) {
            aNewPages[ iFileNo ].lines.push( "  " );
         }

         // Here, we review the line for any remaining links and
         // rewrite the targets to match our output files.
         var liLinkBreak = strThisLine.indexOf( '](#' ); 
         while ( liLinkBreak > -1 ) { 
            var liLinkEnd = strThisLine.indexOf( ')', liLinkBreak );
            var strLinkTarget = strThisLine.substr( liLinkBreak + 2, 
                                    ( liLinkEnd - liLinkBreak ) - 2);
            var liLinkIndex = oLinkData.oldTargets.indexOf( strLinkTarget );

            if ( liLinkIndex == -1 ) {
               oLinkData.oldTargets.push( strLinkTarget );
               console.log( "WARNING: New link target found ( " + 
                            strLinkTarget + "); update .json file." );
            } else {
               strLinkTarget = oLinkData.newTargets[ liLinkIndex ];
               var strNewLine = strThisLine.substr( 0, liLinkBreak + 2 ) + strLinkTarget + 
                                strThisLine.substr( liLinkEnd );
               strThisLine = strNewLine;
            }
            liLinkBreak = strThisLine.indexOf( '](#', liLinkBreak + 1 ); 

         } // while

         // Here's where we figure out whether we add the line 
         // to the array or replace the last line added.

         var liLastLine = -1;
         var strLastLine = "";
         
         if ( aNewPages[ iFileNo ].lines.length > 0 ) {
            liLastLine = aNewPages[ iFileNo ].lines.length - 1;
            strLastLine = aNewPages[ iFileNo ].lines[ liLastLine ];
         }

         if ( ( liLastLine > -1 ) && 
              ( strLastLine.startsWith( "<Returns>" ) ) ) {

            strFirstLetter = strThisLine.substr( 0, 1 );
            aNewPages[ iFileNo ].lines[ liLastLine ] = 
               "**Returns**: " + strFirstLetter.toUpperCase() +
               strThisLine.substr( 1 );

         }  else {
            aNewPages[ iFileNo ].lines.push( strThisLine );
         }

         // If the last line written to the file starts with a 
         // parameter, add a blank line.

         if ( strThisLine.startsWith( "* " ) || 
            ( strThisLine.startsWith( "**Returns**: " ) ) ) {
            aNewPages[ iFileNo ].lines.push( "\n" );
         }
      }
   }

   clog( strFilename + " processed; " + aNewPages.length + " page(s) found..." ); 

   // STAGE 2: Calculate filenames for output pages...

   clog( "Calculating filenames..." );

   for ( var xPages = 0; xPages < aNewPages.length; xPages++ ) {
   
      // Because the filename is generated here, there is an additional
      // bit of data clean up because we're OK with the filename containing
      // the namespace, but don't want the namespace in the filename.

      // For now, we're keeping the namespace in the filename. 

      // (It's an awkward design choice, since other cleanup happens 
      // above.  Perhaps filename generation should be done earlier in 
      // the process.  TODO: Consider refactoring things accordingly.)

      var oFile = aNewPages[ xPages ];
      var aryTokens = oFile.lines[0].split( /\W/ );
      var strFilename = "unknown_filename_" + xPages;
      if ( aryTokens.length > 0 ) {
         strFilename = aryTokens.filter( elementHasValue ).join( '_' );
      }
      aNewPages[ xPages ].fileName = strFilename.toLowerCase() + ".md";

      // TODO: Add code to detect and handle duplicates. 
      // TBD

   }

   // Stage 3: Write out the pages...
   clog( "Writing files..." );
   for ( var xFiles = 0; xFiles < aNewPages.length; xFiles++ ) {

      var oFile = aNewPages[ xFiles ];
      var strContent = oFile.lines.join( os.EOL );
      fs.writeFileSync( './output/' + oFile.fileName, strContent, 'utf-8' );

   }

   // TODO: Add code to do this during a debug run.
   fs.writeFileSync( "./logs/lastrun.txt", jStr( aNewPages), 'utf-8' );
   fs.writeFileSync( "./logs/alldecls.txt", jStr( aryAllDecls), 'utf-8' );
   fs.writeFileSync( "./linkconfig.json", jStr( oLinkData ), 'utf-8' );

}

clog( "Done!" );
process.exit();
/*

Version history:
v0.0.4, 3 May 2018 - Refactor handling of Returns and Parameter blocks; streamline
   prototype clean-up, added NYD logic, and take a stab at link rewrites, based on config file.
v0.0.3, 22 April 2018 - Trying to finalize the prototype parsing rules; rewriting 
   the backtick/useless link removal, and assorted other clean-up.
v0.0.2, 18 March 2018 - Adding additional rules to improve clean-up and conversion. 
v0.0.1, 23 February 2018 - Initial prototype completed.
*/