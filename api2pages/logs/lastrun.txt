[
   {
      "lines": [
         "# Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " define FILE_EXPORT       | _Not yet documented._",
         " public const std::string& GetCustomSettingPolicyDataName()       |  Name of the setting to explicitly specify policy data.",
         " public const std::string& GetCustomSettingExportPolicyFileName()       |  Name of the setting to explicitly specify file path to export SCC policy data to.",
         " public const std::string& GetCustomSettingPolicyDataFile()       |  Name of the setting to explicitly specify policy data file path.",
         " namespace mip  | _Not yet documented._",
         " class mip::FileProfile::Observer  |  [Observer](class_mip_fileprofile_observer.md) interface for clients to get notifications for profile related events.",
         " class mip::Profile::Observer  |  [Observer](class_mip_profile_observer.md) interface for clients to get notifications for profile related events.",
         " class mip::ProtectionProfile::Observer  |  Interface that receives notifications related to [ProtectionProfile](class_mip_protectionprofile.md).",
         " class mip::FileHandler::Observer  |  [Observer](class_mip_filehandler_observer.md) interface for clients to get notifications for file handler related events.",
         " class mip::FileEngine::Settings  | _Not yet documented._",
         " class mip::PolicyEngine::Settings  |  An instance of this class with the approprieted parameters should be provide to initiate an engine.",
         " class mip::FileProfile::Settings  |  [Settings](class_fileprofile_settings.md) used by [FileProfile](class_mip_fileprofile.md) during its creation and throughout its lifetime.",
         " class mip::Profile::Settings  | _Not yet documented._",
         " class mip::ProtectionProfile::Settings  |  [Settings](class_mip_protectionprofile_settings.md) used by [ProtectionProfile](class_mip_protectionprofile.md) during its creation and throughout its lifetime.",
         " struct ApplicationInfo  |  Application identifier as set in the aad portal.",
         "  ",
         "## Members",
         "  ",
         "### FILE_EXPORT",
         "_Not documented yet._\n",
         "  ",
         "### GetCustomSettingPolicyDataName",
         "Name of the setting to explicitly specify policy data.",
         "\n  ",
         "**Returns**: The custom settings key.",
         "  ",
         "### GetCustomSettingExportPolicyFileName",
         "Name of the setting to explicitly specify file path to export SCC policy data to.",
         "\n  ",
         "**Returns**: The custom settings key.",
         "  ",
         "### GetCustomSettingPolicyDataFile",
         "Name of the setting to explicitly specify policy data file path.",
         "\n  ",
         "**Returns**: The custom settings key."
      ],
      "declarations": [
         {
            "declName": "FILE_EXPORT",
            "declType": " define FILE_EXPORT      ",
            "declaration": " define FILE_EXPORT      "
         },
         {
            "declName": "GetCustomSettingPolicyDataName",
            "declType": " public inline const std::string& GetCustomSettingPolicyDataName()      ",
            "declaration": " public const std::string& GetCustomSettingPolicyDataName()      "
         },
         {
            "declName": "GetCustomSettingExportPolicyFileName",
            "declType": " public inline const std::string& GetCustomSettingExportPolicyFileName()      ",
            "declaration": " public const std::string& GetCustomSettingExportPolicyFileName()      "
         },
         {
            "declName": "GetCustomSettingPolicyDataFile",
            "declType": " public inline const std::string& GetCustomSettingPolicyDataFile()      ",
            "declaration": " public const std::string& GetCustomSettingPolicyDataFile()      "
         },
         {
            "declName": "mip",
            "declType": " namespace mip ",
            "declaration": " namespace mip "
         },
         {
            "declName": "mip::FileProfile::Observer",
            "declType": " class mip::FileProfile::Observer ",
            "declaration": " class mip::FileProfile::Observer "
         },
         {
            "declName": "mip::Profile::Observer",
            "declType": " class mip::Profile::Observer ",
            "declaration": " class mip::Profile::Observer "
         },
         {
            "declName": "mip::ProtectionProfile::Observer",
            "declType": " class mip::ProtectionProfile::Observer ",
            "declaration": " class mip::ProtectionProfile::Observer "
         },
         {
            "declName": "mip::FileHandler::Observer",
            "declType": " class mip::FileHandler::Observer ",
            "declaration": " class mip::FileHandler::Observer "
         },
         {
            "declName": "mip::FileEngine::Settings",
            "declType": " class mip::FileEngine::Settings ",
            "declaration": " class mip::FileEngine::Settings "
         },
         {
            "declName": "mip::PolicyEngine::Settings",
            "declType": " class mip::PolicyEngine::Settings ",
            "declaration": " class mip::PolicyEngine::Settings "
         },
         {
            "declName": "mip::FileProfile::Settings",
            "declType": " class mip::FileProfile::Settings ",
            "declaration": " class mip::FileProfile::Settings "
         },
         {
            "declName": "mip::Profile::Settings",
            "declType": " class mip::Profile::Settings ",
            "declaration": " class mip::Profile::Settings "
         },
         {
            "declName": "mip::ProtectionProfile::Settings",
            "declType": " class mip::ProtectionProfile::Settings ",
            "declaration": " class mip::ProtectionProfile::Settings "
         },
         {
            "declName": "ApplicationInfo",
            "declType": " struct ApplicationInfo ",
            "declaration": " struct ApplicationInfo "
         }
      ],
      "fileName": "summary.md"
   },
   {
      "lines": [
         "# namespace `mip` ",
         "Copyright (c) Microsoft Corporation. All rights reserved.",
         "This code is licensed under the MIT License.",
         "Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files(the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and / or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions :",
         "The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.",
         "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " enum ErrorType       | _Not yet documented._",
         " enum ResponseCacheFlags       |  Bit flags that dictate the caching behavior of server responses for [UserPolicy](class_mip_userpolicy.md) aquisition.",
         " enum ConsentType       |  Identifies the type of user consent requested by the SDK.",
         " enum GetUserPolicyResultStatus       |  Describes status of user policy acquisition request.",
         " enum PolicyAcquisitionOptions       |  Describes the mode for acquisition operation.",
         " enum UserPolicyCreationOptions       |  Bit flags that dictate additional policy creation behavior.",
         " enum UserPolicyType       |  Origin type of policy.",
         " enum ActionType       |  Different action types.",
         "public MIP_EXPORT mip::SharedStream CreateStreamFromStdStream(std::shared_ptr<std::istream> stdIStream)       |  Creates an [IStream](class_mip_stream.md) from a std::istream.",
         "public MIP_EXPORT mip::SharedStream CreateStreamFromStdStream(std::shared_ptr<std::ostream> stdOStream)       |  Creates an [IStream](class_mip_stream.md) from a std::ostream.",
         "public MIP_EXPORT mip::SharedStream CreateStreamFromStdStream(std::shared_ptr<std::iostream> stdIOStream)       |  Creates an [IStream](class_mip_stream.md) from a std::iostream.",
         " public ActionType operator &(ActionType a, ActionType b)       |  And (&) operator for [Action](class_mip_action.md) type enum.",
         " public ActionType operator^(ActionType a, ActionType b)       |  Xor (^) operator for [Action](class_mip_action.md) type enum.",
         " class mip::AccessDeniedError  |  The user could not get access to the content. e.g. no permissions, content revoked etc.",
         " class mip::Action  |  Interface for an action.",
         " class mip::AddContentFooterAction  |  An action class which specifies adding a content footer to the document.",
         " class mip::AddContentHeaderAction  |  An action class that specifies adding content header.",
         " class mip::AddWatermarkAction  |  An action class that specifies adding watermark.",
         " class mip::BadInputError  |  Bad input error, input to the sdk api was invalid.",
         " class mip::CommonRights  |  Universally supported rights.",
         " class mip::Consent  |  Represents a user's acceptance/refusal to allow an action.",
         " class mip::ConsentCallback  |  Interface for consent request notifications.",
         " class mip::ConsentResult  |  Describes result of consent request after user interaction.",
         " class mip::ContentLabel  |  Abstraction for a Microsoft Information Protection label that is applied to a piece of content, typically a document.",
         " class mip::CustomAction  |  [CustomAction](class_mip_customaction.md) is a generic action class that captures all the sub-properties of the action as a property bag. The caller is responsible to understand the meaning of the action.",
         " class mip::CustomProtectedStream  |  Wraps a stream to provide transparent encryption and decryption on read and write.",
         " class mip::EditableDocumentRights  |  Rights that apply to editable documents.",
         " class mip::EmailRights  |  Rights that apply to email.",
         " class mip::Error  |  Base class for all errors that will be reported (thrown or returned) from MIP SDK.",
         " class mip::ExecutionState  |  Interface for all the state needed to execute the engine.",
         " class mip::FileEngine  |  Interface for all engine functions.",
         " class mip::FileHandler  |  Interface for all file handling functions.",
         " class mip::FileIOError  |  File IO error.",
         " class mip::FileProfile  |  [FileProfile](class_mip_fileprofile.md) class is the root class for using the Microsoft Information Protection operations.",
         " class mip::GetUserPolicyResult  |  Describes the results of a user policy acquisition request.",
         " class mip::InternalError  |  Internal sdk error. Somthing unexpected happen.",
         " class mip::IStream  |  Base interface for protected streams.",
         " class mip::JustificationRequiredError  | _Not yet documented._",
         " class mip::JustifyAction  |  Justify [Action](class_mip_action.md) requires providing a justfication to a label downgrade and setting the response in the execution state.",
         " class mip::Label  |  Abstraction for a single Microsoft Information Protection label.",
         " class mip::LabelingOptions  |  Interface for configuring labeling options for the SetLabel method.",
         " class mip::MetadataAction  |  An [Action](class_mip_action.md) meant that specifies what meta data information should be added to the content.",
         " class mip::NetworkError  |  Networking error.",
         " class mip::NotSupportedError  |  Operation not supported error.",
         " class mip::PolicyDescriptor  |  Represents an ad-hoc policy associated with protected content.",
         " class mip::PolicyEngine  |  This class provides an interface for all engine functions.",
         " class mip::PrivilegedRequiredError  |  Current label was set by privilidge assignment method cannot override.",
         " class mip::Profile  |  [Profile](class_mip_profile.md) class is the root class for using the Microsoft Information Protection operations. A typical application will only need one [Profile](class_mip_profile.md) but it can create multiple profiles if needed.",
         " class mip::ProtectAdhocAction  |  An action class which specifies adding adhoc protection to the document.",
         " class mip::ProtectByTemplateAction  |  An action class which specifies adding protection by template to the document.",
         " class mip::ProtectDoNotForwardAction  |  An action class which specifies adding do not forward protection to the document.",
         " class mip::ProtectionProfile  |  [ProtectionProfile](class_mip_protectionprofile.md) is the root class for performing protection operations.",
         " class mip::RemoveContentFooterAction  |  An action class which specifies removing the content footer from the document.",
         " class mip::RemoveContentHeaderAction  |  An action class which specifies removing the content header from the document.",
         " class mip::RemoveProtectionAction  |  An action class which specifies removing protection from the document.",
         " class mip::RemoveWatermarkAction  |  An action class which specifies removing the watermarking from the document.",
         " class mip::Roles  |  Defines roles for protecting data.",
         " class mip::Stream  |  A class that defines the interface between the mip sdk and stream based content.",
         " class mip::TemplateDescriptor  |  Describes an RMS template.",
         " class mip::UserPolicy  |  Represents the policy associated with protected content.",
         " class mip::UserRights  |  Represents a group of users and the rights associated with them.",
         " class mip::UserRoles  |  Represents a group of users and the roles associated with them.",
         "  ",
         "## Members",
         "  ",
         "### ErrorType",
         " Values                         | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "BAD_INPUT_ERROR            | Caller passed bad input.",
         "FILE_IO_ERROR            | General File IO error.",
         "NETWORK_ERROR            | General network issues; e.g. unreachable service.",
         "INTERNAL_ERROR            | Internal unexpected errors. e.g. in client-server protocol (received unexpected response).",
         "JUSTIFICATION_REQUIRED            | Justification should be provided to complete the action on the file.",
         "NOT_SUPPORTED_OPERATION            | The requested operation is not yet supported.",
         "PRIVILEGED_REQUIRED            | Can't override privileged label when new label method is standard.",
         "ACCESS_DENIED            | The user could not get access to the content. e.g. no permissions, content revoked etc.",
         "  ",
         "### ResponseCacheFlags",
         " Values                         | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "RESPONSE_CACHE_NOCACHE            | No caching",
         "RESPONSE_CACHE_INMEMORY            | Results are cached in memory",
         "RESPONSE_CACHE_ONDISK            | Results are cached on disk",
         "RESPONSE_CACHE_CRYPTED            | Disk-cached results are encrypted",
         "Bit flags that dictate the caching behavior of server responses for [UserPolicy](class_mip_userpolicy.md) aquisition.",
         "When a [UserPolicy](class_mip_userpolicy.md) is acquired from a server, the SDK can optionally cache the policy so that future acquisition attempts do not require a server request until the policy expires.",
         "  ",
         "### ConsentType",
         " Values                         | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "DocumentTrackingConsent            | [Consent](class_mip_consent.md) for document tracking",
         "ServiceUrlConsent            | [Consent](class_mip_consent.md) for contacting a service url",
         "Identifies the type of user consent requested by the SDK.",
         "  ",
         "### GetUserPolicyResultStatus",
         " Values                         | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "Success            | Success",
         "NoRights            | User has no rights to content",
         "Expired            | Content expired",
         "Describes status of user policy acquisition request.",
         "  ",
         "### PolicyAcquisitionOptions",
         " Values                         | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "POL_None            | Default - Allows UI and network operations.",
         "POL_OfflineOnly            | Do not allow UI and network operations.",
         "Describes the mode for acquisition operation.",
         "  ",
         "### UserPolicyCreationOptions",
         " Values                         | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "USER_None            | None",
         "USER_AllowAuditedExtraction            | Content can be opened in a non-RMS-aware app",
         "USER_PreferDeprecatedAlgorithms            | Use deprecated crypto algorithms (ECB) for backwards compatibility",
         "Bit flags that dictate additional policy creation behavior.",
         "  ",
         "### UserPolicyType",
         " Values                         | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "TemplateBased            | Policy was created from a template",
         "Custom            | Policy was created ad hoc",
         "Origin type of policy.",
         "  ",
         "### ActionType",
         " Values                         | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "ADD_CONTENT_FOOTER            | Add a content footer to the document action type.",
         "ADD_CONTENT_HEADER            | Add a content header to the document action type.",
         "ADD_WATERMARK            | Add a water mark to the entire document action type.",
         "CUSTOM            | A custom defined action type.",
         "JUSTIFY            | A justify action type.",
         "METADATA            | A Meta data change action type.",
         "PROTECT_ADHOC            | A protect by adhoc policy action type.",
         "PROTECT_BY_TEMPLATE            | A protect by template action type.",
         "PROTECT_DO_NOT_FORWARD            | A protect by do not forward action type.",
         "REMOVE_CONTENT_FOOTER            | Remove content footer action type.",
         "REMOVE_CONTENT_HEADER            | Remove content header action type.",
         "REMOVE_PROTECTION            | Remove protection action type.",
         "REMOVE_WATERMARK            | Remove watermarking action type.",
         "Different action types.",
         "CUSTOM is the generic action type. Every other action type is a specific action with a specific meaning.",
         "  ",
         "### mip::SharedStream",
         "Creates an [IStream](class_mip_stream.md) from a std::istream.",
         "\nParameters:  ",
         "* **stdIStream**: Backing std::istream",
         "\n",
         "\n  ",
         "**Returns**: [IStream](class_mip_stream.md) wrapping a std::istream",
         "  ",
         "### mip::SharedStream",
         "Creates an [IStream](class_mip_stream.md) from a std::ostream.",
         "\nParameters:  ",
         "* **stdOStream**: Backing std::ostream",
         "\n",
         "\n  ",
         "**Returns**: [IStream](class_mip_stream.md) wrapping a std::ostream",
         "  ",
         "### mip::SharedStream",
         "Creates an [IStream](class_mip_stream.md) from a std::iostream.",
         "\nParameters:  ",
         "* **stdIOStream**: Backing std::iostream",
         "\n",
         "\n  ",
         "**Returns**: [IStream](class_mip_stream.md) wrapping a std::iostream",
         "  ",
         "### UserPolicyCreationOptions",
         "UserPolicyCreationOptions bitwise OR operator.",
         "\nParameters:  ",
         "* **a**: Left value ",
         "\n",
         "* **b**: Right value",
         "\n",
         "\n  ",
         "**Returns**: Bitwise OR of parameters",
         "  ",
         "### ActionType",
         "Or (|) operator for [Action](class_mip_action.md) type enum.",
         "  ",
         "### ActionType",
         "And (&) operator for [Action](class_mip_action.md) type enum.",
         "  ",
         "### ActionType",
         "Xor (^) operator for [Action](class_mip_action.md) type enum."
      ],
      "declarations": [
         {
            "declName": "ErrorType",
            "declType": " enum ErrorType      ",
            "declaration": " enum ErrorType      "
         },
         {
            "declName": "ResponseCacheFlags",
            "declType": " enum ResponseCacheFlags      ",
            "declaration": " enum ResponseCacheFlags      "
         },
         {
            "declName": "ConsentType",
            "declType": " enum ConsentType      ",
            "declaration": " enum ConsentType      "
         },
         {
            "declName": "GetUserPolicyResultStatus",
            "declType": " enum GetUserPolicyResultStatus      ",
            "declaration": " enum GetUserPolicyResultStatus      "
         },
         {
            "declName": "PolicyAcquisitionOptions",
            "declType": " enum PolicyAcquisitionOptions      ",
            "declaration": " enum PolicyAcquisitionOptions      "
         },
         {
            "declName": "UserPolicyCreationOptions",
            "declType": " enum UserPolicyCreationOptions      ",
            "declaration": " enum UserPolicyCreationOptions      "
         },
         {
            "declName": "UserPolicyType",
            "declType": " enum UserPolicyType      ",
            "declaration": " enum UserPolicyType      "
         },
         {
            "declName": "ActionType",
            "declType": " enum ActionType      ",
            "declaration": " enum ActionType      "
         },
         {
            "declName": "CreateStreamFromStdStream",
            "declType": " MIP_EXPORT mip::SharedStream CreateStreamFromStdStream(std::shared_ptr<std::istream> stdIStream)      ",
            "declaration": "public MIP_EXPORT mip::SharedStream CreateStreamFromStdStream(std::shared_ptr<std::istream> stdIStream)      "
         },
         {
            "declName": "CreateStreamFromStdStream",
            "declType": " MIP_EXPORT mip::SharedStream CreateStreamFromStdStream(std::shared_ptr<std::ostream> stdOStream)      ",
            "declaration": "public MIP_EXPORT mip::SharedStream CreateStreamFromStdStream(std::shared_ptr<std::ostream> stdOStream)      "
         },
         {
            "declName": "CreateStreamFromStdStream",
            "declType": " MIP_EXPORT mip::SharedStream CreateStreamFromStdStream(std::shared_ptr<std::iostream> stdIOStream)      ",
            "declaration": "public MIP_EXPORT mip::SharedStream CreateStreamFromStdStream(std::shared_ptr<std::iostream> stdIOStream)      "
         },
         {
            "declName": "&",
            "declType": " public inline ActionType operator &(ActionType a, ActionType b)      ",
            "declaration": " public ActionType operator &(ActionType a, ActionType b)      "
         },
         {
            "declName": "operator^",
            "declType": " public inline ActionType operator^(ActionType a, ActionType b)      ",
            "declaration": " public ActionType operator^(ActionType a, ActionType b)      "
         },
         {
            "declName": "mip::AccessDeniedError",
            "declType": " class mip::AccessDeniedError ",
            "declaration": " class mip::AccessDeniedError "
         },
         {
            "declName": "mip::Action",
            "declType": " class mip::Action ",
            "declaration": " class mip::Action "
         },
         {
            "declName": "mip::AddContentFooterAction",
            "declType": " class mip::AddContentFooterAction ",
            "declaration": " class mip::AddContentFooterAction "
         },
         {
            "declName": "mip::AddContentHeaderAction",
            "declType": " class mip::AddContentHeaderAction ",
            "declaration": " class mip::AddContentHeaderAction "
         },
         {
            "declName": "mip::AddWatermarkAction",
            "declType": " class mip::AddWatermarkAction ",
            "declaration": " class mip::AddWatermarkAction "
         },
         {
            "declName": "mip::BadInputError",
            "declType": " class mip::BadInputError ",
            "declaration": " class mip::BadInputError "
         },
         {
            "declName": "mip::CommonRights",
            "declType": " class mip::CommonRights ",
            "declaration": " class mip::CommonRights "
         },
         {
            "declName": "mip::Consent",
            "declType": " class mip::Consent ",
            "declaration": " class mip::Consent "
         },
         {
            "declName": "mip::ConsentCallback",
            "declType": " class mip::ConsentCallback ",
            "declaration": " class mip::ConsentCallback "
         },
         {
            "declName": "mip::ConsentResult",
            "declType": " class mip::ConsentResult ",
            "declaration": " class mip::ConsentResult "
         },
         {
            "declName": "mip::ContentLabel",
            "declType": " class mip::ContentLabel ",
            "declaration": " class mip::ContentLabel "
         },
         {
            "declName": "mip::CustomAction",
            "declType": " class mip::CustomAction ",
            "declaration": " class mip::CustomAction "
         },
         {
            "declName": "mip::CustomProtectedStream",
            "declType": " class mip::CustomProtectedStream ",
            "declaration": " class mip::CustomProtectedStream "
         },
         {
            "declName": "mip::EditableDocumentRights",
            "declType": " class mip::EditableDocumentRights ",
            "declaration": " class mip::EditableDocumentRights "
         },
         {
            "declName": "mip::EmailRights",
            "declType": " class mip::EmailRights ",
            "declaration": " class mip::EmailRights "
         },
         {
            "declName": "mip::Error",
            "declType": " class mip::Error ",
            "declaration": " class mip::Error "
         },
         {
            "declName": "mip::ExecutionState",
            "declType": " class mip::ExecutionState ",
            "declaration": " class mip::ExecutionState "
         },
         {
            "declName": "mip::FileEngine",
            "declType": " class mip::FileEngine ",
            "declaration": " class mip::FileEngine "
         },
         {
            "declName": "mip::FileHandler",
            "declType": " class mip::FileHandler ",
            "declaration": " class mip::FileHandler "
         },
         {
            "declName": "mip::FileIOError",
            "declType": " class mip::FileIOError ",
            "declaration": " class mip::FileIOError "
         },
         {
            "declName": "mip::FileProfile",
            "declType": " class mip::FileProfile ",
            "declaration": " class mip::FileProfile "
         },
         {
            "declName": "mip::GetUserPolicyResult",
            "declType": " class mip::GetUserPolicyResult ",
            "declaration": " class mip::GetUserPolicyResult "
         },
         {
            "declName": "mip::InternalError",
            "declType": " class mip::InternalError ",
            "declaration": " class mip::InternalError "
         },
         {
            "declName": "mip::IStream",
            "declType": " class mip::IStream ",
            "declaration": " class mip::IStream "
         },
         {
            "declName": "mip::JustificationRequiredError",
            "declType": " class mip::JustificationRequiredError ",
            "declaration": " class mip::JustificationRequiredError "
         },
         {
            "declName": "mip::JustifyAction",
            "declType": " class mip::JustifyAction ",
            "declaration": " class mip::JustifyAction "
         },
         {
            "declName": "mip::Label",
            "declType": " class mip::Label ",
            "declaration": " class mip::Label "
         },
         {
            "declName": "mip::LabelingOptions",
            "declType": " class mip::LabelingOptions ",
            "declaration": " class mip::LabelingOptions "
         },
         {
            "declName": "mip::MetadataAction",
            "declType": " class mip::MetadataAction ",
            "declaration": " class mip::MetadataAction "
         },
         {
            "declName": "mip::NetworkError",
            "declType": " class mip::NetworkError ",
            "declaration": " class mip::NetworkError "
         },
         {
            "declName": "mip::NotSupportedError",
            "declType": " class mip::NotSupportedError ",
            "declaration": " class mip::NotSupportedError "
         },
         {
            "declName": "mip::PolicyDescriptor",
            "declType": " class mip::PolicyDescriptor ",
            "declaration": " class mip::PolicyDescriptor "
         },
         {
            "declName": "mip::PolicyEngine",
            "declType": " class mip::PolicyEngine ",
            "declaration": " class mip::PolicyEngine "
         },
         {
            "declName": "mip::PrivilegedRequiredError",
            "declType": " class mip::PrivilegedRequiredError ",
            "declaration": " class mip::PrivilegedRequiredError "
         },
         {
            "declName": "mip::Profile",
            "declType": " class mip::Profile ",
            "declaration": " class mip::Profile "
         },
         {
            "declName": "mip::ProtectAdhocAction",
            "declType": " class mip::ProtectAdhocAction ",
            "declaration": " class mip::ProtectAdhocAction "
         },
         {
            "declName": "mip::ProtectByTemplateAction",
            "declType": " class mip::ProtectByTemplateAction ",
            "declaration": " class mip::ProtectByTemplateAction "
         },
         {
            "declName": "mip::ProtectDoNotForwardAction",
            "declType": " class mip::ProtectDoNotForwardAction ",
            "declaration": " class mip::ProtectDoNotForwardAction "
         },
         {
            "declName": "mip::ProtectionProfile",
            "declType": " class mip::ProtectionProfile ",
            "declaration": " class mip::ProtectionProfile "
         },
         {
            "declName": "mip::RemoveContentFooterAction",
            "declType": " class mip::RemoveContentFooterAction ",
            "declaration": " class mip::RemoveContentFooterAction "
         },
         {
            "declName": "mip::RemoveContentHeaderAction",
            "declType": " class mip::RemoveContentHeaderAction ",
            "declaration": " class mip::RemoveContentHeaderAction "
         },
         {
            "declName": "mip::RemoveProtectionAction",
            "declType": " class mip::RemoveProtectionAction ",
            "declaration": " class mip::RemoveProtectionAction "
         },
         {
            "declName": "mip::RemoveWatermarkAction",
            "declType": " class mip::RemoveWatermarkAction ",
            "declaration": " class mip::RemoveWatermarkAction "
         },
         {
            "declName": "mip::Roles",
            "declType": " class mip::Roles ",
            "declaration": " class mip::Roles "
         },
         {
            "declName": "mip::Stream",
            "declType": " class mip::Stream ",
            "declaration": " class mip::Stream "
         },
         {
            "declName": "mip::TemplateDescriptor",
            "declType": " class mip::TemplateDescriptor ",
            "declaration": " class mip::TemplateDescriptor "
         },
         {
            "declName": "mip::UserPolicy",
            "declType": " class mip::UserPolicy ",
            "declaration": " class mip::UserPolicy "
         },
         {
            "declName": "mip::UserRights",
            "declType": " class mip::UserRights ",
            "declaration": " class mip::UserRights "
         },
         {
            "declName": "mip::UserRoles",
            "declType": " class mip::UserRoles ",
            "declaration": " class mip::UserRoles "
         }
      ],
      "fileName": "namespace_mip.md"
   },
   {
      "lines": [
         "# class mip::AccessDeniedError ",
         "The user could not get access to the content. e.g. no permissions, content revoked etc.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_accessdeniederror.md"
   },
   {
      "lines": [
         "# class mip::Action ",
         "Interface for an action.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public ActionType GetType() const  |  Get the type of [Action](class_mip_action.md).",
         "  ",
         "## Members",
         "  ",
         "### ActionType",
         "Get the type of [Action](class_mip_action.md).",
         "\n  ",
         "**Returns**: ActionType The type of derived action this base class can be cast to."
      ],
      "declarations": [
         {
            "declName": "GetType",
            "declType": " public ActionType GetType() const ",
            "declaration": " public ActionType GetType() const "
         }
      ],
      "fileName": "class_mip_action.md"
   },
   {
      "lines": [
         "# class mip::AddContentFooterAction ",
         "An action class which specifies adding a content footer to the document.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public const std::string& GetUIElementName()  |  An API used to mark the content footer element.",
         " public const std::string& GetText() const  |  Get the text thats meant to go into the content footer.",
         " public const std::string& GetFontName() const  |  Get the font name, used to display the content footer.",
         " public int GetFontSize() const  |  Get the font size, used to display the content footer.",
         " public const std::string& GetFontColor() const  |  Get the font color, used to display the content footer.",
         " public ContentMarkAlignment GetAlignment() const  |  Get the Alignment of the footer.",
         " public int GetMargin() const  |  Get the margin of the footer from the bottom.",
         "  ",
         "## Members",
         "  ",
         "### GetUIElementName",
         "An API used to mark the content footer element.",
         "\n  ",
         "**Returns**: The name that should be used for the UI element that holds the content footer. The same name will be returned in [RemoveContentFooterAction](class_mip_removecontentfooteraction.md) in case the content footer needs to be removed.",
         "  ",
         "### GetText",
         "Get the text thats meant to go into the content footer.",
         "\n  ",
         "**Returns**: Content footer text.",
         "  ",
         "### GetFontName",
         "Get the font name, used to display the content footer.",
         "\n  ",
         "**Returns**: Font name, default value if not set by policy Calibri.",
         "  ",
         "### GetFontSize",
         "Get the font size, used to display the content footer.",
         "\n  ",
         "**Returns**: Font size as an integer.",
         "  ",
         "### GetFontColor",
         "Get the font color, used to display the content footer.",
         "\n  ",
         "**Returns**: Font color as a string (e.g.\"#000000\").",
         "  ",
         "### GetAlignment",
         "Get the Alignment of the footer.",
         "\n  ",
         "**Returns**: The ContentMarkAlignment enumerator, LEFT|RIGHT|CENTER. ",
         "  ",
         "**See also**: ContentMarkAlignment",
         "  ",
         "### GetMargin",
         "Get the margin of the footer from the bottom.",
         "\n  ",
         "**Returns**: An integer represeting the margins from the bottom of the document (e.g. 10 mm)."
      ],
      "declarations": [
         {
            "declName": "GetUIElementName",
            "declType": " public const std::string& GetUIElementName() ",
            "declaration": " public const std::string& GetUIElementName() "
         },
         {
            "declName": "GetText",
            "declType": " public const std::string& GetText() const ",
            "declaration": " public const std::string& GetText() const "
         },
         {
            "declName": "GetFontName",
            "declType": " public const std::string& GetFontName() const ",
            "declaration": " public const std::string& GetFontName() const "
         },
         {
            "declName": "GetFontSize",
            "declType": " public int GetFontSize() const ",
            "declaration": " public int GetFontSize() const "
         },
         {
            "declName": "GetFontColor",
            "declType": " public const std::string& GetFontColor() const ",
            "declaration": " public const std::string& GetFontColor() const "
         },
         {
            "declName": "GetAlignment",
            "declType": " public ContentMarkAlignment GetAlignment() const ",
            "declaration": " public ContentMarkAlignment GetAlignment() const "
         },
         {
            "declName": "GetMargin",
            "declType": " public int GetMargin() const ",
            "declaration": " public int GetMargin() const "
         }
      ],
      "fileName": "class_mip_addcontentfooteraction.md"
   },
   {
      "lines": [
         "# class mip::AddContentHeaderAction ",
         "An action class that specifies adding content header.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public const std::string& GetUIElementName()  |  An API used to mark the content header element.",
         " public const std::string& GetText() const  |  Get the text thats meant to go into the content header.",
         " public const std::string& GetFontName() const  |  Get the font name, used to display the content header.",
         " public int GetFontSize() const  |  Get the font size, used to display the content header.",
         " public const std::string& GetFontColor() const  |  Get the font color, used to display the content header.",
         " public ContentMarkAlignment GetAlignment() const  |  Get the Alignment of the header.",
         " public int GetMargin() const  |  Get the margin of the header from the bottom.",
         "  ",
         "## Members",
         "  ",
         "### GetUIElementName",
         "An API used to mark the content header element.",
         "\n  ",
         "**Returns**: The name that should be used for the UI element that holds the content header. The same name will be returned in [RemoveContentHeaderAction](class_mip_removecontentheaderaction.md) in case the content header needs to be removed.",
         "  ",
         "### GetText",
         "Get the text thats meant to go into the content header.",
         "\n  ",
         "**Returns**: Content header text.",
         "  ",
         "### GetFontName",
         "Get the font name, used to display the content header.",
         "\n  ",
         "**Returns**: Font name, default value if not set by policy Calibri.",
         "  ",
         "### GetFontSize",
         "Get the font size, used to display the content header.",
         "\n  ",
         "**Returns**: Font size as an integer.",
         "  ",
         "### GetFontColor",
         "Get the font color, used to display the content header.",
         "\n  ",
         "**Returns**: Font color as a string (e.g.\"#000000\").",
         "  ",
         "### GetAlignment",
         "Get the Alignment of the header.",
         "\n  ",
         "**Returns**: The ContentMarkAlignment enumerator, LEFT|RIGHT|CENTER. ",
         "  ",
         "**See also**: ContentMarkAlignment",
         "  ",
         "### GetMargin",
         "Get the margin of the header from the bottom.",
         "\n  ",
         "**Returns**: An integer represeting the margins from the bottom of the document (e.g. 10 mm)."
      ],
      "declarations": [
         {
            "declName": "GetUIElementName",
            "declType": " public const std::string& GetUIElementName() ",
            "declaration": " public const std::string& GetUIElementName() "
         },
         {
            "declName": "GetText",
            "declType": " public const std::string& GetText() const ",
            "declaration": " public const std::string& GetText() const "
         },
         {
            "declName": "GetFontName",
            "declType": " public const std::string& GetFontName() const ",
            "declaration": " public const std::string& GetFontName() const "
         },
         {
            "declName": "GetFontSize",
            "declType": " public int GetFontSize() const ",
            "declaration": " public int GetFontSize() const "
         },
         {
            "declName": "GetFontColor",
            "declType": " public const std::string& GetFontColor() const ",
            "declaration": " public const std::string& GetFontColor() const "
         },
         {
            "declName": "GetAlignment",
            "declType": " public ContentMarkAlignment GetAlignment() const ",
            "declaration": " public ContentMarkAlignment GetAlignment() const "
         },
         {
            "declName": "GetMargin",
            "declType": " public int GetMargin() const ",
            "declaration": " public int GetMargin() const "
         }
      ],
      "fileName": "class_mip_addcontentheaderaction.md"
   },
   {
      "lines": [
         "# class mip::AddWatermarkAction ",
         "An action class that specifies adding watermark.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public const std::string& GetUIElementName()  |  An API used to mark the watermark element.",
         " public WatermarkLayout GetLayout() const  |  An API used to get the water mark layout.",
         " public const std::string& GetText() const  |  Get the text thats meant to go into the content header.",
         " public const std::string& GetFontName() const  |  Get the font name, used to display the content header.",
         " public int GetFontSize() const  |  Get the font size, used to display the content header.",
         " public const std::string& GetFontColor() const  |  Get the font color, used to display the content header.",
         "  ",
         "## Members",
         "  ",
         "### GetUIElementName",
         "An API used to mark the watermark element.",
         "\n  ",
         "**Returns**: The name that should be used for the UI element that holds the watermark. The same name will be returned in RemoveWatermarkingAction in case the watermark needs to be removed.",
         "  ",
         "### GetLayout",
         "An API used to get the water mark layout.",
         "\n  ",
         "**Returns**: WatermarkLayout the watermarking layout in th form of an enum HORIZONTAL|DIAGONAL. ,",
         "  ",
         "### GetText",
         "Get the text thats meant to go into the content header.",
         "\n  ",
         "**Returns**: Content header text.",
         "  ",
         "### GetFontName",
         "Get the font name, used to display the content header.",
         "\n  ",
         "**Returns**: Font name, default value if not set by policy Calibri.",
         "  ",
         "### GetFontSize",
         "Get the font size, used to display the content header.",
         "\n  ",
         "**Returns**: Font size as an integer.",
         "  ",
         "### GetFontColor",
         "Get the font color, used to display the content header.",
         "\n  ",
         "**Returns**: Font color as a string (e.g.\"#000000\")."
      ],
      "declarations": [
         {
            "declName": "GetUIElementName",
            "declType": " public const std::string& GetUIElementName() ",
            "declaration": " public const std::string& GetUIElementName() "
         },
         {
            "declName": "GetLayout",
            "declType": " public WatermarkLayout GetLayout() const ",
            "declaration": " public WatermarkLayout GetLayout() const "
         },
         {
            "declName": "GetText",
            "declType": " public const std::string& GetText() const ",
            "declaration": " public const std::string& GetText() const "
         },
         {
            "declName": "GetFontName",
            "declType": " public const std::string& GetFontName() const ",
            "declaration": " public const std::string& GetFontName() const "
         },
         {
            "declName": "GetFontSize",
            "declType": " public int GetFontSize() const ",
            "declaration": " public int GetFontSize() const "
         },
         {
            "declName": "GetFontColor",
            "declType": " public const std::string& GetFontColor() const ",
            "declaration": " public const std::string& GetFontColor() const "
         }
      ],
      "fileName": "class_mip_addwatermarkaction.md"
   },
   {
      "lines": [
         "# class mip::BadInputError ",
         "Bad input error, input to the sdk api was invalid.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_badinputerror.md"
   },
   {
      "lines": [
         "# class mip::CommonRights ",
         "Universally supported rights.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_commonrights.md"
   },
   {
      "lines": [
         "# class mip::Consent ",
         "Represents a user's acceptance/refusal to allow an action.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public const mip::ConsentResult& Result() const  |  Gets the result of a consent request.",
         " public void Result(const ConsentResult& value)  |  Sets the result of a consent request.",
         " public mip::ConsentType Type() const  |  Gets the type of consent.",
         "public const std::vector<std::string> Urls() const  |  Gets the URLs involved in the consent request.",
         " public const std::string User() const  |  Gets the user (email address) from whom consent is requested.",
         " public const std::string Domain() const  |  Gets the domain associated with the user from whom consent is requested.",
         "  ",
         "## Members",
         "  ",
         "### mip::ConsentResult",
         "Gets the result of a consent request.",
         "\n  ",
         "**Returns**: Result of consent request",
         "  ",
         "### Result",
         "Sets the result of a consent request.",
         "\nParameters:  ",
         "* **value**: Result of consent request",
         "\n",
         "  ",
         "### mip::ConsentType",
         "Gets the type of consent.",
         "\n  ",
         "**Returns**: Type of consent",
         "  ",
         "### Urls",
         "Gets the URLs involved in the consent request.",
         "\n  ",
         "**Returns**: URLs involved in the consent request",
         "  ",
         "### User",
         "Gets the user (email address) from whom consent is requested.",
         "\n  ",
         "**Returns**: User from whom consent is requested",
         "  ",
         "### Domain",
         "Gets the domain associated with the user from whom consent is requested.",
         "\n  ",
         "**Returns**: Domain associated with the user from whom consent is requested"
      ],
      "declarations": [
         {
            "declName": "Result",
            "declType": " public const mip::ConsentResult& Result() const ",
            "declaration": " public const mip::ConsentResult& Result() const "
         },
         {
            "declName": "Result",
            "declType": " public void Result(const ConsentResult& value) ",
            "declaration": " public void Result(const ConsentResult& value) "
         },
         {
            "declName": "Type",
            "declType": " public mip::ConsentType Type() const ",
            "declaration": " public mip::ConsentType Type() const "
         },
         {
            "declName": "Urls",
            "declType": " const std::vector<std::string> Urls() const ",
            "declaration": "public const std::vector<std::string> Urls() const "
         },
         {
            "declName": "User",
            "declType": " public const std::string User() const ",
            "declaration": " public const std::string User() const "
         },
         {
            "declName": "Domain",
            "declType": " public const std::string Domain() const ",
            "declaration": " public const std::string Domain() const "
         }
      ],
      "fileName": "class_mip_consent.md"
   },
   {
      "lines": [
         "# class mip::ConsentCallback ",
         "Interface for consent request notifications.",
         "This callback is implemented by a client application to know when a consent notification should be displayed to the user.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public ConsentList Consents(ConsentList& consents)  |  Called when SDK requires user consent for an operation.",
         "  ",
         "## Members",
         "  ",
         "### ConsentList",
         "Called when SDK requires user consent for an operation.",
         "\nParameters:  ",
         "* **consents**: The list of consents requested by SDK",
         "\n",
         "\n  ",
         "**Returns**: [Consent](class_mip_consent.md) results",
         "When consents are requested by the SDK, the client application should obtain consent from the user, the results of each consent should be stored via [Consent::Result(const ConsentResult&)](class_mip_consent.md#result), and a list of the resolved consents should be returned."
      ],
      "declarations": [
         {
            "declName": "Consents",
            "declType": " public ConsentList Consents(ConsentList& consents) ",
            "declaration": " public ConsentList Consents(ConsentList& consents) "
         }
      ],
      "fileName": "class_mip_consentcallback.md"
   },
   {
      "lines": [
         "# class mip::ConsentResult ",
         "Describes result of consent request after user interaction.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public ConsentResult(bool accepted, bool showAgain, const std::string& userId)  |  [ConsentResult](class_mip_consentresult.md) constructor.",
         " public bool Accepted() const  |  Gets whether or not user consented to action.",
         " public bool ShowAgain() const  |  Gets whether or not explicit consent is required for future requests.",
         " public const std::string& UserId() const  |  Gets user (email address) from whom consent was requested.",
         "  ",
         "## Members",
         "  ",
         "### ConsentResult",
         "[ConsentResult](class_mip_consentresult.md) constructor.",
         "\nParameters:  ",
         "* **accepted**: Whether or not user consented to action ",
         "\n",
         "* **showAgain**: Whether or not explicit consent is required for future action requests ",
         "\n",
         "* **userId**: User (email address) from whom consent was requested",
         "\n",
         "  ",
         "### Accepted",
         "Gets whether or not user consented to action.",
         "\n  ",
         "**Returns**: Whether or not user contented to action",
         "  ",
         "### ShowAgain",
         "Gets whether or not explicit consent is required for future requests.",
         "\n  ",
         "**Returns**: Whether or not explicit consent is required for future requests",
         "If this is true, the SDK will remember the result of this consent and not prompt the client application for consent in the future.",
         "  ",
         "### UserId",
         "Gets user (email address) from whom consent was requested.",
         "\n  ",
         "**Returns**: User from whom consent was requested"
      ],
      "declarations": [
         {
            "declName": "ConsentResult",
            "declType": " public inline ConsentResult(bool accepted, bool showAgain, const std::string& userId) ",
            "declaration": " public ConsentResult(bool accepted, bool showAgain, const std::string& userId) "
         },
         {
            "declName": "Accepted",
            "declType": " public inline bool Accepted() const ",
            "declaration": " public bool Accepted() const "
         },
         {
            "declName": "ShowAgain",
            "declType": " public inline bool ShowAgain() const ",
            "declaration": " public bool ShowAgain() const "
         },
         {
            "declName": "UserId",
            "declType": " public inline const std::string& UserId() const ",
            "declaration": " public const std::string& UserId() const "
         }
      ],
      "fileName": "class_mip_consentresult.md"
   },
   {
      "lines": [
         "# class mip::ContentLabel ",
         "Abstraction for a Microsoft Information Protection label that is applied to a piece of content, typically a document.",
         "In addition to the label information, it holds properties for a specific applied label.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public const std::string& GetCreationTime() const  |  Get the creation time of the label.",
         " public AssignmentMethod GetAssignmentMethod() const  |  Get the assignment method of the label.",
         "public std::shared_ptr<Label> GetLabel() const  |  Get the actual label object applied on the content.",
         "  ",
         "## Members",
         "  ",
         "### GetCreationTime",
         "Get the creation time of the label.",
         "\n  ",
         "**Returns**: Creation time as a gmt string.",
         "  ",
         "### GetAssignmentMethod",
         "Get the assignment method of the label.",
         "\n  ",
         "**Returns**: AssignmentMethod STANDARD | PRIVILEGED | AUTO. ",
         "  ",
         "**See also**: mip::AssignmentMethod",
         "  ",
         "### Label",
         "Get the actual label object applied on the content.",
         "\n  ",
         "**Returns**: The label object applied on the content. ",
         "  ",
         "**See also**: [mip::Label](class_mip_label.md)"
      ],
      "declarations": [
         {
            "declName": "GetCreationTime",
            "declType": " public const std::string& GetCreationTime() const ",
            "declaration": " public const std::string& GetCreationTime() const "
         },
         {
            "declName": "GetAssignmentMethod",
            "declType": " public AssignmentMethod GetAssignmentMethod() const ",
            "declaration": " public AssignmentMethod GetAssignmentMethod() const "
         },
         {
            "declName": "GetLabel",
            "declType": " std::shared_ptr<Label> GetLabel() const ",
            "declaration": "public std::shared_ptr<Label> GetLabel() const "
         }
      ],
      "fileName": "class_mip_contentlabel.md"
   },
   {
      "lines": [
         "# class mip::CustomAction ",
         "[CustomAction](class_mip_customaction.md) is a generic action class that captures all the sub-properties of the action as a property bag. The caller is responsible to understand the meaning of the action.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "public const std::vector<std::pair<std::string, std::string>>& GetProperties() const  |  Get the properties key value pair list.",
         "  ",
         "## Members",
         "  ",
         "### GetProperties",
         "Get the properties key value pair list.",
         "\n  ",
         "**Returns**: A key value pair list."
      ],
      "declarations": [
         {
            "declName": "GetProperties",
            "declType": " const std::vector<std::pair<std::string, std::string>>& GetProperties() const ",
            "declaration": "public const std::vector<std::pair<std::string, std::string>>& GetProperties() const "
         }
      ],
      "fileName": "class_mip_customaction.md"
   },
   {
      "lines": [
         "# class mip::CustomProtectedStream ",
         "Wraps a stream to provide transparent encryption and decryption on read and write.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_customprotectedstream.md"
   },
   {
      "lines": [
         "# class mip::EditableDocumentRights ",
         "Rights that apply to editable documents.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_editabledocumentrights.md"
   },
   {
      "lines": [
         "# class mip::EmailRights ",
         "Rights that apply to email.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_emailrights.md"
   },
   {
      "lines": [
         "# class mip::Error ",
         "Base class for all errors that will be reported (thrown or returned) from MIP SDK.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public char const* what() const  |  Get a cstring error message.",
         "public std::shared_ptr<Error> Clone() const  |  Clone the error.",
         " public virtual ErrorType GetErrorType() const  |  Get the error type.",
         " public virtual const std::string& GetErrorName() const  |  Get the error name.",
         " public virtual const std::string& GetMessage() const  |  Get the error message.",
         " public virtual void SetMessage(const std::string& msg)  |  Set the error message.",
         "  ",
         "## Members",
         "  ",
         "### what",
         "Get a cstring error message.",
         "\n  ",
         "**Returns**: A cstring err message",
         "  ",
         "### Error",
         "Clone the error.",
         "\n  ",
         "**Returns**: A clone of the error.",
         "  ",
         "### ErrorType",
         "Get the error type.",
         "\n  ",
         "**Returns**: The error type.",
         "  ",
         "### GetErrorName",
         "Get the error name.",
         "\n  ",
         "**Returns**: The error name.",
         "  ",
         "### GetMessage",
         "Get the error message.",
         "\n  ",
         "**Returns**: The error message.",
         "  ",
         "### SetMessage",
         "Set the error message.",
         "\nParameters:  ",
         "* **msg**: the error message.",
         "\n"
      ],
      "declarations": [
         {
            "declName": "what",
            "declType": " public inline char const* what() const ",
            "declaration": " public char const* what() const "
         },
         {
            "declName": "Clone",
            "declType": " std::shared_ptr<Error> Clone() const ",
            "declaration": "public std::shared_ptr<Error> Clone() const "
         },
         {
            "declName": "GetErrorType",
            "declType": " public inline virtual ErrorType GetErrorType() const ",
            "declaration": " public virtual ErrorType GetErrorType() const "
         },
         {
            "declName": "GetErrorName",
            "declType": " public inline virtual const std::string& GetErrorName() const ",
            "declaration": " public virtual const std::string& GetErrorName() const "
         },
         {
            "declName": "GetMessage",
            "declType": " public inline virtual const std::string& GetMessage() const ",
            "declaration": " public virtual const std::string& GetMessage() const "
         },
         {
            "declName": "SetMessage",
            "declType": " public inline virtual void SetMessage(const std::string& msg) ",
            "declaration": " public virtual void SetMessage(const std::string& msg) "
         }
      ],
      "fileName": "class_mip_error.md"
   },
   {
      "lines": [
         "# class mip::ExecutionState ",
         "Interface for all the state needed to execute the engine.",
         "Clients should only call the methods to obtain the state that is needed. Hence, for efficiency, clients may want to implement this interface such that the corresponding state is computed dynamically instead of computing in advance.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public std::string GetNewLabelId() const  |  Gets the sensitivity label id that should be applied on the document.",
         " public bool IsDowngradeJustified() const  |  Implementation should pass whether or not justification to downgrade an existing label was given.",
         " public AssignmentMethod GetNewLabelAssignmentMethod() const  |  Get the new label's assignment method.",
         "public std::vector<std::pair<std::string, std::string>> GetContentMetadata(const std::vector<std::string>& names, const std::vector<std::string>& namePrefixes) const  |  Get the meta-data items from the content.",
         " public std::string GetTemplateId() const  |  Gets the rights managment service protection template id.",
         " public ContentFormat GetContentFormat() const  |  Gets the content format.",
         " public const ActionType GetSupportedActions() const  |  Return a list of actions that the application supports. All actions types are listed in [mip/upe/action.h](#action).",
         "  ",
         "## Members",
         "  ",
         "### GetNewLabelId",
         "Gets the sensitivity label id that should be applied on the document.",
         "\n  ",
         "**Returns**: Sensitivity label id to be applied to the content if exists else empty to remove label.",
         "  ",
         "### IsDowngradeJustified",
         "Implementation should pass whether or not justification to downgrade an existing label was given.",
         "\n  ",
         "**Returns**: True if downgrade is already justified, false if it hasn't yet been justified. ",
         "  ",
         "**See also**: [mip::JustifyAction](class_mip_justifyaction.md)",
         "  ",
         "### GetNewLabelAssignmentMethod",
         "Get the new label's assignment method.",
         "\n  ",
         "**Returns**: The assignment method STANDARD, PRIVILEGED, AUTO. ",
         "  ",
         "**See also**: mip::AssignmentMethod",
         "  ",
         "### GetContentMetadata",
         "Get the meta-data items from the content.",
         "\n  ",
         "**Returns**: A vector of key value pairs representing the meta data applied to the content. ",
         "Each meta-data item is a pair of name and value.",
         "  ",
         "### GetTemplateId",
         "Gets the rights managment service protection template id.",
         "\n  ",
         "**Returns**: The rights managment service protection template id if exists else in a guid format without braces, return an empty string.",
         "  ",
         "### GetContentFormat",
         "Gets the content format.",
         "\n  ",
         "**Returns**: DEFAULT, EMAIL ",
         "  ",
         "**See also**: mip::ContentFormat",
         "  ",
         "### ActionType",
         "Return a list of actions that the application supports. All actions types are listed in [mip/upe/action.h](#action)."
      ],
      "declarations": [
         {
            "declName": "GetNewLabelId",
            "declType": " public std::string GetNewLabelId() const ",
            "declaration": " public std::string GetNewLabelId() const "
         },
         {
            "declName": "IsDowngradeJustified",
            "declType": " public bool IsDowngradeJustified() const ",
            "declaration": " public bool IsDowngradeJustified() const "
         },
         {
            "declName": "GetNewLabelAssignmentMethod",
            "declType": " public AssignmentMethod GetNewLabelAssignmentMethod() const ",
            "declaration": " public AssignmentMethod GetNewLabelAssignmentMethod() const "
         },
         {
            "declName": "GetContentMetadata",
            "declType": " std::vector<std::pair<std::string, std::string>> GetContentMetadata(const std::vector<std::string>& names, const std::vector<std::string>& namePrefixes) const ",
            "declaration": "public std::vector<std::pair<std::string, std::string>> GetContentMetadata(const std::vector<std::string>& names, const std::vector<std::string>& namePrefixes) const "
         },
         {
            "declName": "GetTemplateId",
            "declType": " public std::string GetTemplateId() const ",
            "declaration": " public std::string GetTemplateId() const "
         },
         {
            "declName": "GetContentFormat",
            "declType": " public ContentFormat GetContentFormat() const ",
            "declaration": " public ContentFormat GetContentFormat() const "
         },
         {
            "declName": "GetSupportedActions",
            "declType": " public const ActionType GetSupportedActions() const ",
            "declaration": " public const ActionType GetSupportedActions() const "
         }
      ],
      "fileName": "class_mip_executionstate.md"
   },
   {
      "lines": [
         "# class mip::FileEngine ",
         "Interface for all engine functions.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public virtual ~FileEngine()  | _Not yet documented._",
         " public const Settings& GetSettings() const  |  Returns the engine settings.",
         "public const std::vector<std::shared_ptr<Label>>& ListSensitivityLabels()  |  Returns a list of sensitivity labels.",
         "public std::shared_ptr<FileHandler> CreateFileHandler(const std::string& inputFilePath, const std::shared_ptr<FileHandler::Observer>& fileHandlerObserver)  |  Returns the file handler for given file path.",
         "public std::shared_ptr<FileHandler> CreateFileHandler(const std::shared_ptr<Stream>& inputStream, const std::string& inputFileName, const std::shared_ptr<FileHandler::Observer>& fileHandlerObserver)  |  Returns the file handler for given file stream.",
         " protected FileEngine()  | _Not yet documented._",
         "  ",
         "## Members",
         "  ",
         "### ~FileEngine",
         "_Not documented yet._\n",
         "  ",
         "### Settings",
         "Returns the engine settings.",
         "  ",
         "### Label",
         "Returns a list of sensitivity labels.",
         "  ",
         "### FileHandler",
         "Returns the file handler for given file path.",
         "\nParameters:  ",
         "* **The**: file to open. The path must include the file name and, if one exists, the file name extension. ",
         "\n",
         "* **A**: class implementing the [FileHandler::Observer](class_mip_filehandler_observer.md) interface.",
         "\n",
         "  ",
         "### FileHandler",
         "Returns the file handler for given file stream.",
         "\nParameters:  ",
         "* **A**: stream that represents the file. ",
         "\n",
         "* **The**: path to the file. The path must include the file name and, if one exists, the file name extension. ",
         "\n",
         "* **A**: class implementing the [FileHandler::Observer](class_mip_filehandler_observer.md) interface.",
         "\n",
         "  ",
         "### FileEngine",
         "_Not documented yet._\n"
      ],
      "declarations": [
         {
            "declName": "~FileEngine",
            "declType": " public inline virtual ~FileEngine() ",
            "declaration": " public virtual ~FileEngine() "
         },
         {
            "declName": "GetSettings",
            "declType": " public const Settings& GetSettings() const ",
            "declaration": " public const Settings& GetSettings() const "
         },
         {
            "declName": "ListSensitivityLabels",
            "declType": " const std::vector<std::shared_ptr<Label>>& ListSensitivityLabels() ",
            "declaration": "public const std::vector<std::shared_ptr<Label>>& ListSensitivityLabels() "
         },
         {
            "declName": "CreateFileHandler",
            "declType": " std::shared_ptr<FileHandler> CreateFileHandler(const std::string& inputFilePath, const std::shared_ptr<FileHandler::Observer>& fileHandlerObserver) ",
            "declaration": "public std::shared_ptr<FileHandler> CreateFileHandler(const std::string& inputFilePath, const std::shared_ptr<FileHandler::Observer>& fileHandlerObserver) "
         },
         {
            "declName": "CreateFileHandler",
            "declType": " std::shared_ptr<FileHandler> CreateFileHandler(const std::shared_ptr<Stream>& inputStream, const std::string& inputFileName, const std::shared_ptr<FileHandler::Observer>& fileHandlerObserver) ",
            "declaration": "public std::shared_ptr<FileHandler> CreateFileHandler(const std::shared_ptr<Stream>& inputStream, const std::string& inputFileName, const std::shared_ptr<FileHandler::Observer>& fileHandlerObserver) "
         },
         {
            "declName": "FileEngine",
            "declType": " protected inline FileEngine() ",
            "declaration": " protected FileEngine() "
         }
      ],
      "fileName": "class_mip_fileengine.md"
   },
   {
      "lines": [
         "# class mip::FileHandler ",
         "Interface for all file handling functions.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "public void GetLabelAsync(const std::shared_ptr<void>& context)  |  Starts retrieving the sensitivity label from the file.",
         "public void GetProtectionAsync(const std::shared_ptr<void>& context)  |  Starts retrieving the protection policy from the file.",
         " public void SetLabel(const std::string& labelId, const LabelingOptions& labelingOptions)  |  Sets the sensitivity label to the file.",
         " public void DeleteLabel(AssignmentMethod method, const std::string& justificationMessage)  |  Deletes the sensitivity label from the file.",
         "public void SetCustomPermissions(const std::shared_ptr<PolicyDescriptor>& policyDescriptor)  |  Sets custom permissions to the file.",
         " public void RemoveProtection()  |  Removes protection from the file. If the file is labeled, the label will be lost.",
         "public void CommitAsync(const std::string& outputFilePath, const std::shared_ptr<void>& context) | Writes the changes to the file specified by the \\|outputFilePath\\ |  parameter.",
         "public void CommitAsync(const std::shared_ptr<Stream>& outputStream, const std::shared_ptr<void>& context) | Writes the changes to the stream specified by the \\|outputStream\\ |  parameter.",
         " public std::string GetOutputFileName()  |  Calculates the output file name and extension based on the original file name and the accumulated changes.",
         " public virtual ~FileHandler()  | _Not yet documented._",
         " protected FileHandler()  | _Not yet documented._",
         "  ",
         "## Members",
         "  ",
         "### GetLabelAsync",
         "Starts retrieving the sensitivity label from the file.",
         "[FileHandler::Observer](class_mip_filehandler_observer.md) will be called upon success or failure.",
         "\nParameters:  ",
         "* **context**: Client context that will be opaquely passed back to the observer.",
         "\n",
         "  ",
         "### GetProtectionAsync",
         "Starts retrieving the protection policy from the file.",
         "[FileHandler::Observer](class_mip_filehandler_observer.md) will be called upon success or failure.",
         "\nParameters:  ",
         "* **context**: Client context that will be opaquely passed back to the observer.",
         "\n",
         "  ",
         "### SetLabel",
         "Sets the sensitivity label to the file.",
         "Changes will not be written to the file until CommitAsync will be called.",
         "Throws [JustificationRequiredError](class_mip_justificationrequirederror.md) when setting the label requires a justification and no justification message was provided via the labelingOptions parameter.",
         "  ",
         "### DeleteLabel",
         "Deletes the sensitivity label from the file.",
         "Changes will not be written to the file until CommitAsync will be called. Privilegd and Auto method allows the API to override any existing label ",
         "Throws [JustificationRequiredError](class_mip_justificationrequirederror.md) when setting the label requires a justification and no justification message was provided via the justificationMessage parameter.",
         "  ",
         "### SetCustomPermissions",
         "Sets custom permissions to the file.",
         "Changes will not be written to the file until CommitAsync will be called.",
         "  ",
         "### RemoveProtection",
         "Removes protection from the file. If the file is labeled, the label will be lost.",
         "Changes will not be written to the file until CommitAsync will be called.",
         "  ",
         "### CommitAsync",
         "Writes the changes to the file specified by the |outputFilePath| parameter.",
         "[FileHandler::Observer](class_mip_filehandler_observer.md) will be called upon success or failure.",
         "  ",
         "### CommitAsync",
         "Writes the changes to the stream specified by the |outputStream| parameter.",
         "[FileHandler::Observer](class_mip_filehandler_observer.md) will be called upon success or failure.",
         "  ",
         "### GetOutputFileName",
         "Calculates the output file name and extension based on the original file name and the accumulated changes.",
         "  ",
         "### ~FileHandler",
         "_Not documented yet._\n",
         "  ",
         "### FileHandler",
         "_Not documented yet._\n"
      ],
      "declarations": [
         {
            "declName": "GetLabelAsync",
            "declType": " void GetLabelAsync(const std::shared_ptr<void>& context) ",
            "declaration": "public void GetLabelAsync(const std::shared_ptr<void>& context) "
         },
         {
            "declName": "GetProtectionAsync",
            "declType": " void GetProtectionAsync(const std::shared_ptr<void>& context) ",
            "declaration": "public void GetProtectionAsync(const std::shared_ptr<void>& context) "
         },
         {
            "declName": "SetLabel",
            "declType": " public void SetLabel(const std::string& labelId, const LabelingOptions& labelingOptions) ",
            "declaration": " public void SetLabel(const std::string& labelId, const LabelingOptions& labelingOptions) "
         },
         {
            "declName": "DeleteLabel",
            "declType": " public void DeleteLabel(AssignmentMethod method, const std::string& justificationMessage) ",
            "declaration": " public void DeleteLabel(AssignmentMethod method, const std::string& justificationMessage) "
         },
         {
            "declName": "SetCustomPermissions",
            "declType": " void SetCustomPermissions(const std::shared_ptr<PolicyDescriptor>& policyDescriptor) ",
            "declaration": "public void SetCustomPermissions(const std::shared_ptr<PolicyDescriptor>& policyDescriptor) "
         },
         {
            "declName": "RemoveProtection",
            "declType": " public void RemoveProtection() ",
            "declaration": " public void RemoveProtection() "
         },
         {
            "declName": "CommitAsync",
            "declType": " void CommitAsync(const std::string& outputFilePath, const std::shared_ptr<void>& context) | Writes the changes to the file specified by the \\|outputFilePath\\",
            "declaration": "public void CommitAsync(const std::string& outputFilePath, const std::shared_ptr<void>& context) | Writes the changes to the file specified by the \\|outputFilePath\\"
         },
         {
            "declName": "CommitAsync",
            "declType": " void CommitAsync(const std::shared_ptr<Stream>& outputStream, const std::shared_ptr<void>& context) | Writes the changes to the stream specified by the \\|outputStream\\",
            "declaration": "public void CommitAsync(const std::shared_ptr<Stream>& outputStream, const std::shared_ptr<void>& context) | Writes the changes to the stream specified by the \\|outputStream\\"
         },
         {
            "declName": "GetOutputFileName",
            "declType": " public std::string GetOutputFileName() ",
            "declaration": " public std::string GetOutputFileName() "
         },
         {
            "declName": "~FileHandler",
            "declType": " public inline virtual ~FileHandler() ",
            "declaration": " public virtual ~FileHandler() "
         },
         {
            "declName": "FileHandler",
            "declType": " protected inline FileHandler() ",
            "declaration": " protected FileHandler() "
         }
      ],
      "fileName": "class_mip_filehandler.md"
   },
   {
      "lines": [
         "# class mip::FileIOError ",
         "File IO error.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_fileioerror.md"
   },
   {
      "lines": [
         "# class mip::FileProfile ",
         "[FileProfile](class_mip_fileprofile.md) class is the root class for using the Microsoft Information Protection operations.",
         "A typical application will only need one [Profile](class_mip_profile.md) but it can create multiple profiles if needed.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public virtual ~FileProfile()  | _Not yet documented._",
         " public const Settings& GetSettings() const  |  Returns the profile settings.",
         "public void ListEnginesAsync(const std::shared_ptr<void>& context)  |  Starts list engines operation.",
         "public void UnloadEngineAsync(const std::string& id, const std::shared_ptr<void>& context)  |  Starts unloading the file engine with the given id.",
         "public void AddEngineAsync(const FileEngine::Settings& settings, const std::shared_ptr<void>& context)  |  Starts adding a new file engine to the profile.",
         "public void DeleteEngineAsync(const std::string& id, const std::shared_ptr<void>& context)  |  Starts deleting the file engine with the given id. All data for the given profile will be completely deleted.",
         " protected FileProfile()  | _Not yet documented._",
         "  ",
         "## Members",
         "  ",
         "### ~FileProfile",
         "_Not documented yet._\n",
         "  ",
         "### Settings",
         "Returns the profile settings.",
         "  ",
         "### ListEnginesAsync",
         "Starts list engines operation.",
         "[FileProfile::Observer](class_mip_fileprofile_observer.md) will be called upon success or failure.",
         "  ",
         "### UnloadEngineAsync",
         "Starts unloading the file engine with the given id.",
         "[FileProfile::Observer](class_mip_fileprofile_observer.md) will be called upon success or failure.",
         "  ",
         "### AddEngineAsync",
         "Starts adding a new file engine to the profile.",
         "[FileProfile::Observer](class_mip_fileprofile_observer.md) will be called upon success or failure.",
         "  ",
         "### DeleteEngineAsync",
         "Starts deleting the file engine with the given id. All data for the given profile will be completely deleted.",
         "[FileProfile::Observer](class_mip_fileprofile_observer.md) will be called upon success or failure.",
         "  ",
         "### FileProfile",
         "_Not documented yet._\n"
      ],
      "declarations": [
         {
            "declName": "~FileProfile",
            "declType": " public inline virtual ~FileProfile() ",
            "declaration": " public virtual ~FileProfile() "
         },
         {
            "declName": "GetSettings",
            "declType": " public const Settings& GetSettings() const ",
            "declaration": " public const Settings& GetSettings() const "
         },
         {
            "declName": "ListEnginesAsync",
            "declType": " void ListEnginesAsync(const std::shared_ptr<void>& context) ",
            "declaration": "public void ListEnginesAsync(const std::shared_ptr<void>& context) "
         },
         {
            "declName": "UnloadEngineAsync",
            "declType": " void UnloadEngineAsync(const std::string& id, const std::shared_ptr<void>& context) ",
            "declaration": "public void UnloadEngineAsync(const std::string& id, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "AddEngineAsync",
            "declType": " void AddEngineAsync(const FileEngine::Settings& settings, const std::shared_ptr<void>& context) ",
            "declaration": "public void AddEngineAsync(const FileEngine::Settings& settings, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "DeleteEngineAsync",
            "declType": " void DeleteEngineAsync(const std::string& id, const std::shared_ptr<void>& context) ",
            "declaration": "public void DeleteEngineAsync(const std::string& id, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "FileProfile",
            "declType": " protected inline FileProfile() ",
            "declaration": " protected FileProfile() "
         }
      ],
      "fileName": "class_mip_fileprofile.md"
   },
   {
      "lines": [
         "# class mip::GetUserPolicyResult ",
         "Describes the results of a user policy acquisition request.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public GetUserPolicyResultStatus GetResultStatus()  |  Gets the status of the policy acquisition request.",
         "public std::shared_ptr<std::string> GetReferrer()  |  Gets the refererrer address of the policy.",
         "public std::shared_ptr<UserPolicy> GetPolicy()  |  Gets a [UserPolicy](class_mip_userpolicy.md) instance.",
         "  ",
         "## Members",
         "  ",
         "### GetUserPolicyResultStatus",
         "Gets the status of the policy acquisition request.",
         "\n  ",
         "**Returns**: Status of the policy acquisition request",
         "  ",
         "### GetReferrer",
         "Gets the refererrer address of the policy.",
         "\n  ",
         "**Returns**: Referrerer address of the policy",
         "The referrer is a URI that can be displayed to the user upon failed policy acquisition that contains information on how that user can gain permission to access the content.",
         "  ",
         "### UserPolicy",
         "Gets a [UserPolicy](class_mip_userpolicy.md) instance.",
         "\n  ",
         "**Returns**: [UserPolicy](class_mip_userpolicy.md) instance if acquisition was successful, else nullptr"
      ],
      "declarations": [
         {
            "declName": "GetResultStatus",
            "declType": " public GetUserPolicyResultStatus GetResultStatus() ",
            "declaration": " public GetUserPolicyResultStatus GetResultStatus() "
         },
         {
            "declName": "GetReferrer",
            "declType": " std::shared_ptr<std::string> GetReferrer() ",
            "declaration": "public std::shared_ptr<std::string> GetReferrer() "
         },
         {
            "declName": "GetPolicy",
            "declType": " std::shared_ptr<UserPolicy> GetPolicy() ",
            "declaration": "public std::shared_ptr<UserPolicy> GetPolicy() "
         }
      ],
      "fileName": "class_mip_getuserpolicyresult.md"
   },
   {
      "lines": [
         "# class mip::InternalError ",
         "Internal sdk error. Somthing unexpected happen.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_internalerror.md"
   },
   {
      "lines": [
         "# class mip::IStream ",
         "Base interface for protected streams.",
         "Ported from Windows::Storage::Streams::IRandomAccessStream::IRandomAccessStream and Windows::Storage::Streams::FileRandomAccessStream::FileRandomAccessStream. [https://msdn.microsoft.com/en-us/library/windows/apps/windows.storage.streams.irandomaccessstream.aspx](https://msdn.microsoft.com/en-us/library/windows/apps/windows.storage.streams.irandomaccessstream.aspx)[https://msdn.microsoft.com/en-us/library/windows/apps/windows.storage.streams.filerandomaccessstream.aspx](https://msdn.microsoft.com/en-us/library/windows/apps/windows.storage.streams.filerandomaccessstream.aspx)",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "public std::shared_future<int64_t> ReadAsync(uint8_t* pbBuffer, int64_t cbBuffer, int64_t cbOffset, std::launch launchType)  |  Reads a block of data from stream asynchronously.",
         "public std::shared_future<int64_t> WriteAsync(const uint8_t* cpbBuffer, int64_t cbBuffer, int64_t cbOffset, std::launch launchType)  |  Writes a block of data into stream asynchronously.",
         "public std::future<bool> FlushAsync(std::launch launchType)  |  Flushes output stream buffer asynchronously.",
         " public int64_t Read(uint8_t* pbBuffer, int64_t cbBuffer)  |  Reads a block of data from stream synchronously.",
         " public int64_t Write(const uint8_t* cpbBuffer, int64_t cbBuffer)  |  Writes a block of data into stream synchronously.",
         " public bool Flush()  |  Flushes output stream buffer synchronously.",
         " public SharedStream Clone()  |  Clones stream.",
         " public void Seek(uint64_t u64Position)  |  Seeks to a position within the stream.",
         " public bool CanRead() const  |  Gets whether or not stream can be read.",
         " public bool CanWrite() const  |  Gets whether or not stream can be written.",
         " public uint64_t Position()  |  Gets current position of stream from beginning (in bytes)",
         " public uint64_t Size()  |  Gets size of stream (in bytes)",
         " public void Size(uint64_t u64Value)  |  Sets size of stream (in bytes)",
         "public virtual std::vector<uint8_t> Read(uint64_t u64size)  |  Reads a block of data from stream synchronously.",
         "  ",
         "## Members",
         "  ",
         "### ReadAsync",
         "Reads a block of data from stream asynchronously.",
         "\nParameters:  ",
         "* **pbBuffer**: Buffer into which stream should be read ",
         "\n",
         "* **cbBuffer**: Size of buffer ",
         "\n",
         "* **cbOffset**: Offset from beginning of input stream where reading should begin ",
         "\n",
         "* **launchType**: Async launch type",
         "\n",
         "\n  ",
         "**Returns**: Async future containing actual number of bytes read",
         "Ensure buffer exists until result is retreived from std::future",
         "  ",
         "### WriteAsync",
         "Writes a block of data into stream asynchronously.",
         "\nParameters:  ",
         "* **cpbBuffer**: Buffer of data to write ",
         "\n",
         "* **cbBuffer**: Size of buffer ",
         "\n",
         "* **cbOffset**: Offset from beginning of output stream to where writing should begin ",
         "\n",
         "* **launchType**: Async launch type",
         "\n",
         "\n  ",
         "**Returns**: Async future containing actual number of bytes written",
         "Ensure buffer exists until result is retreived from std::future",
         "  ",
         "### FlushAsync",
         "Flushes output stream buffer asynchronously.",
         "\nParameters:  ",
         "* **launchType**: Async launch type",
         "\n",
         "\n  ",
         "**Returns**: Async future containing whether or not flush was successful",
         "  ",
         "### Read",
         "Reads a block of data from stream synchronously.",
         "\nParameters:  ",
         "* **pbBuffer**: Buffer into which stream should be read ",
         "\n",
         "* **cbBuffer**: Size of buffer",
         "\n",
         "\n  ",
         "**Returns**: Actual number of bytes read",
         "  ",
         "### Write",
         "Writes a block of data into stream synchronously.",
         "\nParameters:  ",
         "* **cpbBuffer**: Buffer of data to write ",
         "\n",
         "* **cbBuffer**: Size of buffer",
         "\n",
         "\n  ",
         "**Returns**: Actual number of bytes written",
         "  ",
         "### Flush",
         "Flushes output stream buffer synchronously.",
         "\n  ",
         "**Returns**: Whether or not flush was successful",
         "  ",
         "### SharedStream",
         "Clones stream.",
         "\n  ",
         "**Returns**: Cloned stream",
         "  ",
         "### Seek",
         "Seeks to a position within the stream.",
         "\nParameters:  ",
         "* **u64Position**: Byte offset from beginning of stream",
         "\n",
         "  ",
         "### CanRead",
         "Gets whether or not stream can be read.",
         "\n  ",
         "**Returns**: Whether or not stream can be read",
         "  ",
         "### CanWrite",
         "Gets whether or not stream can be written.",
         "\n  ",
         "**Returns**: Whether or not stream can be written",
         "  ",
         "### Position",
         "Gets current position of stream from beginning (in bytes)",
         "\n  ",
         "**Returns**: Current positition of stream from beginning (in bytes)",
         "  ",
         "### Size",
         "Gets size of stream (in bytes)",
         "\n  ",
         "**Returns**: Size of stream (in bytes)",
         "  ",
         "### Size",
         "Sets size of stream (in bytes)",
         "\nParameters:  ",
         "* **u64Value**: Size of stream (in bytes)",
         "\n",
         "  ",
         "### Read",
         "Reads a block of data from stream synchronously.",
         "\nParameters:  ",
         "* **u64size**: Size of data to read (in bytes)",
         "\n",
         "\n  ",
         "**Returns**: Vector of actual read data"
      ],
      "declarations": [
         {
            "declName": "ReadAsync",
            "declType": " std::shared_future<int64_t> ReadAsync(uint8_t* pbBuffer, int64_t cbBuffer, int64_t cbOffset, std::launch launchType) ",
            "declaration": "public std::shared_future<int64_t> ReadAsync(uint8_t* pbBuffer, int64_t cbBuffer, int64_t cbOffset, std::launch launchType) "
         },
         {
            "declName": "WriteAsync",
            "declType": " std::shared_future<int64_t> WriteAsync(const uint8_t* cpbBuffer, int64_t cbBuffer, int64_t cbOffset, std::launch launchType) ",
            "declaration": "public std::shared_future<int64_t> WriteAsync(const uint8_t* cpbBuffer, int64_t cbBuffer, int64_t cbOffset, std::launch launchType) "
         },
         {
            "declName": "FlushAsync",
            "declType": " std::future<bool> FlushAsync(std::launch launchType) ",
            "declaration": "public std::future<bool> FlushAsync(std::launch launchType) "
         },
         {
            "declName": "Read",
            "declType": " public int64_t Read(uint8_t* pbBuffer, int64_t cbBuffer) ",
            "declaration": " public int64_t Read(uint8_t* pbBuffer, int64_t cbBuffer) "
         },
         {
            "declName": "Write",
            "declType": " public int64_t Write(const uint8_t* cpbBuffer, int64_t cbBuffer) ",
            "declaration": " public int64_t Write(const uint8_t* cpbBuffer, int64_t cbBuffer) "
         },
         {
            "declName": "Flush",
            "declType": " public bool Flush() ",
            "declaration": " public bool Flush() "
         },
         {
            "declName": "Clone",
            "declType": " public SharedStream Clone() ",
            "declaration": " public SharedStream Clone() "
         },
         {
            "declName": "Seek",
            "declType": " public void Seek(uint64_t u64Position) ",
            "declaration": " public void Seek(uint64_t u64Position) "
         },
         {
            "declName": "CanRead",
            "declType": " public bool CanRead() const ",
            "declaration": " public bool CanRead() const "
         },
         {
            "declName": "CanWrite",
            "declType": " public bool CanWrite() const ",
            "declaration": " public bool CanWrite() const "
         },
         {
            "declName": "Position",
            "declType": " public uint64_t Position() ",
            "declaration": " public uint64_t Position() "
         },
         {
            "declName": "Size",
            "declType": " public uint64_t Size() ",
            "declaration": " public uint64_t Size() "
         },
         {
            "declName": "Size",
            "declType": " public void Size(uint64_t u64Value) ",
            "declaration": " public void Size(uint64_t u64Value) "
         },
         {
            "declName": "Read",
            "declType": " inline virtual std::vector<uint8_t> Read(uint64_t u64size) ",
            "declaration": "public virtual std::vector<uint8_t> Read(uint64_t u64size) "
         }
      ],
      "fileName": "class_mip_istream.md"
   },
   {
      "lines": [
         "# class mip::JustificationRequiredError ",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public JustificationRequiredError()  | _Not yet documented._",
         "public virtual std::shared_ptr<Error> Clone() const  |  Clone the error.",
         "  ",
         "## Members",
         "  ",
         "### JustificationRequiredError",
         "_Not documented yet._\n",
         "  ",
         "### Error",
         "Clone the error.",
         "\n  ",
         "**Returns**: A clone of the error."
      ],
      "declarations": [
         {
            "declName": "JustificationRequiredError",
            "declType": " public inline JustificationRequiredError() ",
            "declaration": " public JustificationRequiredError() "
         },
         {
            "declName": "Clone",
            "declType": " inline virtual std::shared_ptr<Error> Clone() const ",
            "declaration": "public virtual std::shared_ptr<Error> Clone() const "
         }
      ],
      "fileName": "class_mip_justificationrequirederror.md"
   },
   {
      "lines": [
         "# class mip::JustifyAction ",
         "Justify [Action](class_mip_action.md) requires providing a justfication to a label downgrade and setting the response in the execution state.",
         "  ",
         "**See also**: [mip::ExecutionState::IsDowngradeJustified](class_mip_executionstate.md#isdowngradejustified)",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_justifyaction.md"
   },
   {
      "lines": [
         "# class mip::Label ",
         "Abstraction for a single Microsoft Information Protection label.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public const std::string& GetId() const  |  Get the label Id.",
         " public const std::string& GetName() const  |  Get the label name.",
         " public const std::string& GetDescription() const  |  Get the label description.",
         " public const std::string& GetColor() const  |  Get the color the label should be displayed.",
         " public const std::string& GetOrder() const  |  Get the Order of the label.",
         " public const std::string& GetTooltip() const  |  Get the tooltip description of the label.",
         " public bool IsActive() const  |  Gets a boolean signaling if the label is active.",
         "public std::weak_ptr<Label> GetParent() const  |  Get the parent label.",
         "public const std::vector<std::shared_ptr<Label>>& GetChildren() const  |  Get the children labels of the current label.",
         "  ",
         "## Members",
         "  ",
         "### GetId",
         "Get the label Id.",
         "\n  ",
         "**Returns**: The label id.",
         "  ",
         "### GetName",
         "Get the label name.",
         "\n  ",
         "**Returns**: The label name.",
         "  ",
         "### GetDescription",
         "Get the label description.",
         "\n  ",
         "**Returns**: The label description.",
         "  ",
         "### GetColor",
         "Get the color the label should be displayed.",
         "\n  ",
         "**Returns**: Color value the string format. \"#RRGGBB\" where each of RR, GG, BB is a hexadecimal 0-f.",
         "  ",
         "### GetOrder",
         "Get the Order of the label.",
         "\n  ",
         "**Returns**: A numerical value ascribed as a string.",
         "  ",
         "### GetTooltip",
         "Get the tooltip description of the label.",
         "\n  ",
         "**Returns**: A tooltip string.",
         "  ",
         "### IsActive",
         "Gets a boolean signaling if the label is active.",
         "Only active labels can be applied. Inactive labels cannot be applied, and are used for display purposes only. ",
         "\n  ",
         "**Returns**: True if label is active, else false.",
         "  ",
         "### Label",
         "Get the parent label.",
         "\n  ",
         "**Returns**: A weak pointer to the parent label if exists else an empty pointer.",
         "  ",
         "### Label",
         "Get the children labels of the current label.",
         "\n  ",
         "**Returns**: A vector of shared pointers to labels."
      ],
      "declarations": [
         {
            "declName": "GetId",
            "declType": " public const std::string& GetId() const ",
            "declaration": " public const std::string& GetId() const "
         },
         {
            "declName": "GetName",
            "declType": " public const std::string& GetName() const ",
            "declaration": " public const std::string& GetName() const "
         },
         {
            "declName": "GetDescription",
            "declType": " public const std::string& GetDescription() const ",
            "declaration": " public const std::string& GetDescription() const "
         },
         {
            "declName": "GetColor",
            "declType": " public const std::string& GetColor() const ",
            "declaration": " public const std::string& GetColor() const "
         },
         {
            "declName": "GetOrder",
            "declType": " public const std::string& GetOrder() const ",
            "declaration": " public const std::string& GetOrder() const "
         },
         {
            "declName": "GetTooltip",
            "declType": " public const std::string& GetTooltip() const ",
            "declaration": " public const std::string& GetTooltip() const "
         },
         {
            "declName": "IsActive",
            "declType": " public bool IsActive() const ",
            "declaration": " public bool IsActive() const "
         },
         {
            "declName": "GetParent",
            "declType": " std::weak_ptr<Label> GetParent() const ",
            "declaration": "public std::weak_ptr<Label> GetParent() const "
         },
         {
            "declName": "GetChildren",
            "declType": " const std::vector<std::shared_ptr<Label>>& GetChildren() const ",
            "declaration": "public const std::vector<std::shared_ptr<Label>>& GetChildren() const "
         }
      ],
      "fileName": "class_mip_label.md"
   },
   {
      "lines": [
         "# class mip::LabelingOptions ",
         "Interface for configuring labeling options for the SetLabel method.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public LabelingOptions(AssignmentMethod method, const std::string& justificationMessage)  | _Not yet documented._",
         " public const std::string& GetJustificationMessage() const  | _Not yet documented._",
         " public AssignmentMethod GetAssignmentMethod() const  | _Not yet documented._",
         " public void SetJustificationMessage(const std::string& justificationMessage)  | _Not yet documented._",
         " public void SetMethod(AssignmentMethod method)  | _Not yet documented._",
         "  ",
         "## Members",
         "  ",
         "### LabelingOptions",
         "_Not documented yet._\n",
         "  ",
         "### GetJustificationMessage",
         "_Not documented yet._\n",
         "  ",
         "### GetAssignmentMethod",
         "_Not documented yet._\n",
         "  ",
         "### SetJustificationMessage",
         "_Not documented yet._\n",
         "  ",
         "### SetMethod",
         "_Not documented yet._\n"
      ],
      "declarations": [
         {
            "declName": "LabelingOptions",
            "declType": " public inline LabelingOptions(AssignmentMethod method, const std::string& justificationMessage) ",
            "declaration": " public LabelingOptions(AssignmentMethod method, const std::string& justificationMessage) "
         },
         {
            "declName": "GetJustificationMessage",
            "declType": " public inline const std::string& GetJustificationMessage() const ",
            "declaration": " public const std::string& GetJustificationMessage() const "
         },
         {
            "declName": "GetAssignmentMethod",
            "declType": " public inline AssignmentMethod GetAssignmentMethod() const ",
            "declaration": " public AssignmentMethod GetAssignmentMethod() const "
         },
         {
            "declName": "SetJustificationMessage",
            "declType": " public inline void SetJustificationMessage(const std::string& justificationMessage) ",
            "declaration": " public void SetJustificationMessage(const std::string& justificationMessage) "
         },
         {
            "declName": "SetMethod",
            "declType": " public inline void SetMethod(AssignmentMethod method) ",
            "declaration": " public void SetMethod(AssignmentMethod method) "
         }
      ],
      "fileName": "class_mip_labelingoptions.md"
   },
   {
      "lines": [
         "# class mip::MetadataAction ",
         "An [Action](class_mip_action.md) meant that specifies what meta data information should be added to the content.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "public const std::vector<std::string>& GetMetadataToRemove() const  |  Get the list of names of meta-data that need to be removed from content.",
         "public const std::vector<std::pair<std::string, std::string>>& GetMetadataToAdd() const  |  Get the list of meta-data as key value pairs. The meta-data needs to be added to content meta-data.",
         "  ",
         "## Members",
         "  ",
         "### GetMetadataToRemove",
         "Get the list of names of meta-data that need to be removed from content.",
         "\n  ",
         "**Returns**: A vector of strings to remove. ",
         "that removing meta-data should be done before adding meta-data.",
         "  ",
         "### GetMetadataToAdd",
         "Get the list of meta-data as key value pairs. The meta-data needs to be added to content meta-data.",
         "\n  ",
         "**Returns**: Const std::vector<std::pair<std::string, std::string>>& ",
         "removing meta-data should be done before adding meta-data."
      ],
      "declarations": [
         {
            "declName": "GetMetadataToRemove",
            "declType": " const std::vector<std::string>& GetMetadataToRemove() const ",
            "declaration": "public const std::vector<std::string>& GetMetadataToRemove() const "
         },
         {
            "declName": "GetMetadataToAdd",
            "declType": " const std::vector<std::pair<std::string, std::string>>& GetMetadataToAdd() const ",
            "declaration": "public const std::vector<std::pair<std::string, std::string>>& GetMetadataToAdd() const "
         }
      ],
      "fileName": "class_mip_metadataaction.md"
   },
   {
      "lines": [
         "# class mip::NetworkError ",
         "Networking error.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_networkerror.md"
   },
   {
      "lines": [
         "# class mip::NotSupportedError ",
         "Operation not supported error.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_notsupportederror.md"
   },
   {
      "lines": [
         "# class mip::PolicyDescriptor ",
         "Represents an ad-hoc policy associated with protected content.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public const std::string& GetName()  |  Gets policy name.",
         " public void SetName(const std::string& value)  |  Sets policy name.",
         " public const std::string& GetDescription()  |  Gets policy description.",
         " public void SetDescription(const std::string& value)  |  Sets policy description.",
         "public const std::vector<UserRights>& GetUserRightsList() const  |  Gets collection of users-to-rights mappings.",
         "public const std::vector<mip::UserRoles>& GetUserRolesList()  |  Gets collection of users-to-roles mappings.",
         "public const std::chrono::time_point<std::chrono::system_clock>& GetContentValidUntil()  |  Gets policy expiration time.",
         "public void SetContentValidUntil(const std::chrono::time_point<std::chrono::system_clock>& value)  |  Sets policy expiration time.",
         " public bool DoesAllowOfflineAccess()  |  Gets whether or not policy allows offline content access.",
         " public void SetAllowOfflineAccess(bool value)  |  Sets whether or not policy allows offline content access.",
         " public const std::string& GetReferrer() const  |  Gets policy referrer address.",
         " public void SetReferrer(const std::string& uri)  |  Sets policy referrer address.",
         " public const AppDataHashMap& GetEncryptedAppData()  |  Gets app-specific data that was encrypted.",
         " public void SetEncryptedAppData(const AppDataHashMap& value)  |  Sets app-specific data that should be encrypted.",
         " public const AppDataHashMap& GetSignedAppData()  |  Gets the app-specific data that was signed.",
         " public void SetSignedAppData(const AppDataHashMap& value)  |  Sets app-specific data that should be signed.",
         "  ",
         "## Members",
         "  ",
         "### GetName",
         "Gets policy name.",
         "\n  ",
         "**Returns**: Policy name",
         "  ",
         "### SetName",
         "Sets policy name.",
         "\nParameters:  ",
         "* **value**: Policy name",
         "\n",
         "  ",
         "### GetDescription",
         "Gets policy description.",
         "\n  ",
         "**Returns**: Policy description",
         "  ",
         "### SetDescription",
         "Sets policy description.",
         "\nParameters:  ",
         "* **value**: Policy description",
         "\n",
         "  ",
         "### UserRights",
         "Gets collection of users-to-rights mappings.",
         "\n  ",
         "**Returns**: Collection of users-to-rights mappings",
         "The value of the UserRightsList property will be empty if the current user doesn't have access to the user rights information (i.e. is not the owner and does not have the VIEWRIGHTSDATA right).",
         "  ",
         "### mip::UserRoles",
         "Gets collection of users-to-roles mappings.",
         "\n  ",
         "**Returns**: Collection of users-to-roles mappings",
         "  ",
         "### GetContentValidUntil",
         "Gets policy expiration time.",
         "\n  ",
         "**Returns**: Policy expiration time",
         "  ",
         "### SetContentValidUntil",
         "Sets policy expiration time.",
         "\nParameters:  ",
         "* **value**: Policy expiration time",
         "\n",
         "  ",
         "### DoesAllowOfflineAccess",
         "Gets whether or not policy allows offline content access.",
         "\n  ",
         "**Returns**: Whether or not policy allows offline content access (default = true)",
         "  ",
         "### SetAllowOfflineAccess",
         "Sets whether or not policy allows offline content access.",
         "\nParameters:  ",
         "* **value**: Whether or not policy allows offline content access",
         "\n",
         "  ",
         "### GetReferrer",
         "Gets policy referrer address.",
         "\n  ",
         "**Returns**: Policy referrer address",
         "The referrer is a URI that can be displayed to the user upon failed policy acquisition that contains information on how that user can gain permission to access the content.",
         "  ",
         "### SetReferrer",
         "Sets policy referrer address.",
         "\nParameters:  ",
         "* **uri**: Policy referrer address",
         "\n",
         "The referrer is a URI that can be displayed to the user upon failed policy acquisition that contains information on how that user can gain permission to access the content.",
         "  ",
         "### AppDataHashMap",
         "Gets app-specific data that was encrypted.",
         "\n  ",
         "**Returns**: App-specific data",
         "A [UserPolicy](class_mip_userpolicy.md) may contain a dictionary of app-specific data that was encrypted by the RMS service. This encrypted data is independent of the signed data accessible via [PolicyDescriptor::GetSignedAppData](class_mip_policydescriptor.md#getsignedappdata)",
         "  ",
         "### SetEncryptedAppData",
         "Sets app-specific data that should be encrypted.",
         "\nParameters:  ",
         "* **value**: App-specific data",
         "\n",
         "An application can specify a dictionary of app-specific data that will be encrypted by the RMS service. This encrypted data is independent of the signed data set by [PolicyDescriptor::SetSignedAppData](class_mip_policydescriptor.md#setsignedappdata).",
         "  ",
         "### AppDataHashMap",
         "Gets the app-specific data that was signed.",
         "\n  ",
         "**Returns**: App-specific data",
         "A [UserPolicy](class_mip_userpolicy.md) may contain a dictionary of app-specific data that was signed by the RMS service. This signed data is independent of the encrypted data accessible via [PolicyDescriptor::GetEncryptedAppData](class_mip_policydescriptor.md#getencryptedappdata)",
         "  ",
         "### SetSignedAppData",
         "Sets app-specific data that should be signed.",
         "\nParameters:  ",
         "* **value**: App-specific data",
         "\n",
         "An application can specify a dictionary of app-specific data that will be signed by the RMS service. This signed data is independent of the encrypted data set by [PolicyDescriptor::SetEncryptedAppData](class_mip_policydescriptor.md#setencryptedappdata)."
      ],
      "declarations": [
         {
            "declName": "GetName",
            "declType": " public const std::string& GetName() ",
            "declaration": " public const std::string& GetName() "
         },
         {
            "declName": "SetName",
            "declType": " public void SetName(const std::string& value) ",
            "declaration": " public void SetName(const std::string& value) "
         },
         {
            "declName": "GetDescription",
            "declType": " public const std::string& GetDescription() ",
            "declaration": " public const std::string& GetDescription() "
         },
         {
            "declName": "SetDescription",
            "declType": " public void SetDescription(const std::string& value) ",
            "declaration": " public void SetDescription(const std::string& value) "
         },
         {
            "declName": "GetUserRightsList",
            "declType": " const std::vector<UserRights>& GetUserRightsList() const ",
            "declaration": "public const std::vector<UserRights>& GetUserRightsList() const "
         },
         {
            "declName": "GetUserRolesList",
            "declType": " const std::vector<mip::UserRoles>& GetUserRolesList() ",
            "declaration": "public const std::vector<mip::UserRoles>& GetUserRolesList() "
         },
         {
            "declName": "GetContentValidUntil",
            "declType": " const std::chrono::time_point<std::chrono::system_clock>& GetContentValidUntil() ",
            "declaration": "public const std::chrono::time_point<std::chrono::system_clock>& GetContentValidUntil() "
         },
         {
            "declName": "SetContentValidUntil",
            "declType": " void SetContentValidUntil(const std::chrono::time_point<std::chrono::system_clock>& value) ",
            "declaration": "public void SetContentValidUntil(const std::chrono::time_point<std::chrono::system_clock>& value) "
         },
         {
            "declName": "DoesAllowOfflineAccess",
            "declType": " public bool DoesAllowOfflineAccess() ",
            "declaration": " public bool DoesAllowOfflineAccess() "
         },
         {
            "declName": "SetAllowOfflineAccess",
            "declType": " public void SetAllowOfflineAccess(bool value) ",
            "declaration": " public void SetAllowOfflineAccess(bool value) "
         },
         {
            "declName": "GetReferrer",
            "declType": " public const std::string& GetReferrer() const ",
            "declaration": " public const std::string& GetReferrer() const "
         },
         {
            "declName": "SetReferrer",
            "declType": " public void SetReferrer(const std::string& uri) ",
            "declaration": " public void SetReferrer(const std::string& uri) "
         },
         {
            "declName": "GetEncryptedAppData",
            "declType": " public const AppDataHashMap& GetEncryptedAppData() ",
            "declaration": " public const AppDataHashMap& GetEncryptedAppData() "
         },
         {
            "declName": "SetEncryptedAppData",
            "declType": " public void SetEncryptedAppData(const AppDataHashMap& value) ",
            "declaration": " public void SetEncryptedAppData(const AppDataHashMap& value) "
         },
         {
            "declName": "GetSignedAppData",
            "declType": " public const AppDataHashMap& GetSignedAppData() ",
            "declaration": " public const AppDataHashMap& GetSignedAppData() "
         },
         {
            "declName": "SetSignedAppData",
            "declType": " public void SetSignedAppData(const AppDataHashMap& value) ",
            "declaration": " public void SetSignedAppData(const AppDataHashMap& value) "
         }
      ],
      "fileName": "class_mip_policydescriptor.md"
   },
   {
      "lines": [
         "# class mip::PolicyEngine ",
         "This class provides an interface for all engine functions.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public const Settings& GetSettings() const  |  Get the policy engine [Settings](class_mip_policyengine_settings.md).",
         "public const std::vector<std::shared_ptr<Label>>& ListSensitivityLabels()  |  list the sensitivity labels associated with the policy engine.",
         "public std::shared_ptr<ContentLabel> GetSensitivityLabel(const ExecutionState& state)  |  Get the sensitivity label from existing content.",
         "public std::shared_ptr<Label> GetDefaultSensitivityLabel()  |  Get the default sensitivity label.",
         "public std::vector<std::shared_ptr<Action>> ComputeActions(const ExecutionState& state, bool isDryRun)  |  Executes the rules in the engine based on the provided state and returns the list of actions to be executed.",
         "  ",
         "## Members",
         "  ",
         "### Settings",
         "Get the policy engine [Settings](class_mip_policyengine_settings.md).",
         "\n  ",
         "**Returns**: Policy engine settings. ",
         "  ",
         "**See also**: [mip::PolicyEngine::Settings](class_mip_policyengine_settings.md)",
         "  ",
         "### Label",
         "list the sensitivity labels associated with the policy engine.",
         "\n  ",
         "**Returns**: A list of sensitivity labels.",
         "  ",
         "### ContentLabel",
         "Get the sensitivity label from existing content.",
         "Required information to retrieve the label will be obtained by using the provided execution state. ",
         "\nParameters:  ",
         "* **state**: ",
         "\n",
         "\n  ",
         "**Returns**: A content label object that contains the sensitivity label as well as additional information. returns empty if non exists. ",
         "  ",
         "**See also**: [mip::ContentLabel](class_mip_contentlabel.md).",
         "  ",
         "### Label",
         "Get the default sensitivity label.",
         "\n  ",
         "**Returns**: Default sensitivy label if exists, nullptr if there is no default label set.",
         "  ",
         "### Action",
         "Executes the rules in the engine based on the provided state and returns the list of actions to be executed.",
         "\nParameters:  ",
         "* **state**: the current execution state of the content the rules are running on. ",
         "\n",
         "* **isDryRun**: specifies if the caller is going to apply actions returned from the function. true - the actions will not be applied by the caller, false otherwise. ",
         "\n",
         "\n  ",
         "**Returns**: List of actions that should be applied on the content."
      ],
      "declarations": [
         {
            "declName": "GetSettings",
            "declType": " public const Settings& GetSettings() const ",
            "declaration": " public const Settings& GetSettings() const "
         },
         {
            "declName": "ListSensitivityLabels",
            "declType": " const std::vector<std::shared_ptr<Label>>& ListSensitivityLabels() ",
            "declaration": "public const std::vector<std::shared_ptr<Label>>& ListSensitivityLabels() "
         },
         {
            "declName": "GetSensitivityLabel",
            "declType": " std::shared_ptr<ContentLabel> GetSensitivityLabel(const ExecutionState& state) ",
            "declaration": "public std::shared_ptr<ContentLabel> GetSensitivityLabel(const ExecutionState& state) "
         },
         {
            "declName": "GetDefaultSensitivityLabel",
            "declType": " std::shared_ptr<Label> GetDefaultSensitivityLabel() ",
            "declaration": "public std::shared_ptr<Label> GetDefaultSensitivityLabel() "
         },
         {
            "declName": "ComputeActions",
            "declType": " std::vector<std::shared_ptr<Action>> ComputeActions(const ExecutionState& state, bool isDryRun) ",
            "declaration": "public std::vector<std::shared_ptr<Action>> ComputeActions(const ExecutionState& state, bool isDryRun) "
         }
      ],
      "fileName": "class_mip_policyengine.md"
   },
   {
      "lines": [
         "# class mip::PrivilegedRequiredError ",
         "Current label was set by privilidge assignment method cannot override.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_privilegedrequirederror.md"
   },
   {
      "lines": [
         "# class mip::Profile ",
         "[Profile](class_mip_profile.md) class is the root class for using the Microsoft Information Protection operations. A typical application will only need one [Profile](class_mip_profile.md) but it can create multiple profiles if needed.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public const Settings& GetSettings() const  |  Get the settings set on the profile.",
         "public void ListEnginesAsync(const std::shared_ptr<void>& context)  |  Starts list engines operation.",
         "public void UnloadEngineAsync(const std::string& id, const std::shared_ptr<void>& context)  |  Starts unloading the policy engine with the given id.",
         "public void AddEngineAsync(const PolicyEngine::Settings& settings, const std::shared_ptr<void>& context)  |  Starts adding a new policy engine to the profile.",
         "public void DeleteEngineAsync(const std::string& id, const std::shared_ptr<void>& context)  |  Starts deleting the policy engine with the given id. All data for the given profile will be completely deleted.",
         "  ",
         "## Members",
         "  ",
         "### Settings",
         "Get the settings set on the profile.",
         "\n  ",
         "**Returns**: Settings set on the profile.",
         "  ",
         "### ListEnginesAsync",
         "Starts list engines operation.",
         "\nParameters:  ",
         "* **context**: a parameter that will be passed into the observer functions. ",
         "\n",
         "[Profile::Observer](class_mip_profile_observer.md) will be called upon success or failure.",
         "  ",
         "### UnloadEngineAsync",
         "Starts unloading the policy engine with the given id.",
         "\nParameters:  ",
         "* **id**: the unique engine id. ",
         "\n",
         "* **context**: a parameter that will be passed into the observer functions. ",
         "\n",
         "[Profile::Observer](class_mip_profile_observer.md) will be called upon success or failure.",
         "  ",
         "### AddEngineAsync",
         "Starts adding a new policy engine to the profile.",
         "\nParameters:  ",
         "* **settings**: the [mip::PolicyEngine::Settings](class_mip_policyengine_settings.md) objet that specifies the engines parameters. ",
         "\n",
         "* **context**: a parameter that will be passed into the observer functions. ",
         "\n",
         "[Profile::Observer](class_mip_profile_observer.md) will be called upon success or failure.",
         "  ",
         "### DeleteEngineAsync",
         "Starts deleting the policy engine with the given id. All data for the given profile will be completely deleted.",
         "\nParameters:  ",
         "* **id**: the unique engine id. ",
         "\n",
         "* **context**: a parameter that will be passed into the observer functions. ",
         "\n",
         "[Profile::Observer](class_mip_profile_observer.md) will be called upon success or failure."
      ],
      "declarations": [
         {
            "declName": "GetSettings",
            "declType": " public const Settings& GetSettings() const ",
            "declaration": " public const Settings& GetSettings() const "
         },
         {
            "declName": "ListEnginesAsync",
            "declType": " void ListEnginesAsync(const std::shared_ptr<void>& context) ",
            "declaration": "public void ListEnginesAsync(const std::shared_ptr<void>& context) "
         },
         {
            "declName": "UnloadEngineAsync",
            "declType": " void UnloadEngineAsync(const std::string& id, const std::shared_ptr<void>& context) ",
            "declaration": "public void UnloadEngineAsync(const std::string& id, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "AddEngineAsync",
            "declType": " void AddEngineAsync(const PolicyEngine::Settings& settings, const std::shared_ptr<void>& context) ",
            "declaration": "public void AddEngineAsync(const PolicyEngine::Settings& settings, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "DeleteEngineAsync",
            "declType": " void DeleteEngineAsync(const std::string& id, const std::shared_ptr<void>& context) ",
            "declaration": "public void DeleteEngineAsync(const std::string& id, const std::shared_ptr<void>& context) "
         }
      ],
      "fileName": "class_mip_profile.md"
   },
   {
      "lines": [
         "# class mip::ProtectAdhocAction ",
         "An action class which specifies adding adhoc protection to the document.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_protectadhocaction.md"
   },
   {
      "lines": [
         "# class mip::ProtectByTemplateAction ",
         "An action class which specifies adding protection by template to the document.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public const std::string& GetTemplateId() const  | _Not yet documented._",
         "  ",
         "## Members",
         "  ",
         "### GetTemplateId",
         "_Not documented yet._\n"
      ],
      "declarations": [
         {
            "declName": "GetTemplateId",
            "declType": " public const std::string& GetTemplateId() const ",
            "declaration": " public const std::string& GetTemplateId() const "
         }
      ],
      "fileName": "class_mip_protectbytemplateaction.md"
   },
   {
      "lines": [
         "# class mip::ProtectDoNotForwardAction ",
         "An action class which specifies adding do not forward protection to the document.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_protectdonotforwardaction.md"
   },
   {
      "lines": [
         "# class mip::ProtectionProfile ",
         "[ProtectionProfile](class_mip_protectionprofile.md) is the root class for performing protection operations.",
         "An application need to create a [ProtectionProfile](class_mip_protectionprofile.md) prior to performing any protection operations",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public const Settings& GetSettings() const  |  Gets settings used by [ProtectionProfile](class_mip_protectionprofile.md) during its initialization and throughout its lifetime.",
         " public void ClearCaches()  |  Deletes caches (e.g. consent databases, etc.)",
         "  ",
         "## Members",
         "  ",
         "### Settings",
         "Gets settings used by [ProtectionProfile](class_mip_protectionprofile.md) during its initialization and throughout its lifetime.",
         "\n  ",
         "**Returns**: [Settings](class_mip_protectionprofile_settings.md) used by [ProtectionProfile](class_mip_protectionprofile.md) during its initialization and throughout its lifetime",
         "  ",
         "### ClearCaches",
         "Deletes caches (e.g. consent databases, etc.)",
         "Useful for debugging/testing"
      ],
      "declarations": [
         {
            "declName": "GetSettings",
            "declType": " public const Settings& GetSettings() const ",
            "declaration": " public const Settings& GetSettings() const "
         },
         {
            "declName": "ClearCaches",
            "declType": " public void ClearCaches() ",
            "declaration": " public void ClearCaches() "
         }
      ],
      "fileName": "class_mip_protectionprofile.md"
   },
   {
      "lines": [
         "# class mip::RemoveContentFooterAction ",
         "An action class which specifies removing the content footer from the document.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "public const std::vector<std::string>& GetUIElementNames()  |  Gets a list of names that should be used to find the UI elements that should be removed.",
         "  ",
         "## Members",
         "  ",
         "### GetUIElementNames",
         "Gets a list of names that should be used to find the UI elements that should be removed.",
         "\n  ",
         "**Returns**: A list of ui element names."
      ],
      "declarations": [
         {
            "declName": "GetUIElementNames",
            "declType": " const std::vector<std::string>& GetUIElementNames() ",
            "declaration": "public const std::vector<std::string>& GetUIElementNames() "
         }
      ],
      "fileName": "class_mip_removecontentfooteraction.md"
   },
   {
      "lines": [
         "# class mip::RemoveContentHeaderAction ",
         "An action class which specifies removing the content header from the document.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "public const std::vector<std::string>& GetUIElementNames()  |  Gets a list of names that should be used to find the UI elements that should be removed.",
         "  ",
         "## Members",
         "  ",
         "### GetUIElementNames",
         "Gets a list of names that should be used to find the UI elements that should be removed.",
         "\n  ",
         "**Returns**: A list of ui element names."
      ],
      "declarations": [
         {
            "declName": "GetUIElementNames",
            "declType": " const std::vector<std::string>& GetUIElementNames() ",
            "declaration": "public const std::vector<std::string>& GetUIElementNames() "
         }
      ],
      "fileName": "class_mip_removecontentheaderaction.md"
   },
   {
      "lines": [
         "# class mip::RemoveProtectionAction ",
         "An action class which specifies removing protection from the document.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_removeprotectionaction.md"
   },
   {
      "lines": [
         "# class mip::RemoveWatermarkAction ",
         "An action class which specifies removing the watermarking from the document.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "public const std::vector<std::string>& GetUIElementNames()  |  Gets a list of names that should be used to find the UI elements that should be removed.",
         "  ",
         "## Members",
         "  ",
         "### GetUIElementNames",
         "Gets a list of names that should be used to find the UI elements that should be removed.",
         "\n  ",
         "**Returns**: A list of ui element names."
      ],
      "declarations": [
         {
            "declName": "GetUIElementNames",
            "declType": " const std::vector<std::string>& GetUIElementNames() ",
            "declaration": "public const std::vector<std::string>& GetUIElementNames() "
         }
      ],
      "fileName": "class_mip_removewatermarkaction.md"
   },
   {
      "lines": [
         "# class mip::Roles ",
         "Defines roles for protecting data.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "  ",
         "## Members",
         "_Not documented yet._\n"
      ],
      "declarations": [],
      "fileName": "class_mip_roles.md"
   },
   {
      "lines": [
         "# class mip::Stream ",
         "A class that defines the interface between the mip sdk and stream based content.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public int64_t Read(uint8_t* buffer, int64_t bufferLength)  |  Read into a buffer from the stream.",
         " public int64_t Write(const uint8_t* buffer, int64_t bufferLength)  |  Write ino the stream from a buffer.",
         " public bool Flush()  |  flush the stream.",
         " public void Seek(uint64_t position)  |  Seek specific position within the stream.",
         " public bool CanRead() const  |  A check if stream is readable.",
         " public bool CanWrite() const  |  A check if stream is writeable.",
         " public uint64_t Position()  |  Get the current position within the stream.",
         " public uint64_t Size()  |  Get the size of the content within the stream.",
         " public void Size(uint64_t value)  |  Set the stream size.",
         "public std::shared_ptr<Stream> Clone()  |  Clone the stream.",
         "  ",
         "## Members",
         "  ",
         "### Read",
         "Read into a buffer from the stream.",
         "\nParameters:  ",
         "* **buffer**: pointer to a buffer ",
         "\n",
         "* **bufferLength**: buffer size. ",
         "\n",
         "\n  ",
         "**Returns**: Number of bytes actually read.",
         "  ",
         "### Write",
         "Write ino the stream from a buffer.",
         "\nParameters:  ",
         "* **buffer**: pointer to a buffer ",
         "\n",
         "* **bufferLength**: buffer size. ",
         "\n",
         "\n  ",
         "**Returns**: Number of bytes actually read.",
         "  ",
         "### Flush",
         "flush the stream.",
         "\n  ",
         "**Returns**: True if successful else false.",
         "  ",
         "### Seek",
         "Seek specific position within the stream.",
         "\nParameters:  ",
         "* **position**: to seek into stream.",
         "\n",
         "  ",
         "### CanRead",
         "A check if stream is readable.",
         "\n  ",
         "**Returns**: True if readable else false.",
         "  ",
         "### CanWrite",
         "A check if stream is writeable.",
         "\n  ",
         "**Returns**: True if writeable else false.",
         "  ",
         "### Position",
         "Get the current position within the stream.",
         "\n  ",
         "**Returns**: Position within the stream.",
         "  ",
         "### Size",
         "Get the size of the content within the stream.",
         "\n  ",
         "**Returns**: The stream size.",
         "  ",
         "### Size",
         "Set the stream size.",
         "\nParameters:  ",
         "* **stream**: size.",
         "\n",
         "  ",
         "### Stream",
         "Clone the stream.",
         "\n  ",
         "**Returns**: New stream."
      ],
      "declarations": [
         {
            "declName": "Read",
            "declType": " public int64_t Read(uint8_t* buffer, int64_t bufferLength) ",
            "declaration": " public int64_t Read(uint8_t* buffer, int64_t bufferLength) "
         },
         {
            "declName": "Write",
            "declType": " public int64_t Write(const uint8_t* buffer, int64_t bufferLength) ",
            "declaration": " public int64_t Write(const uint8_t* buffer, int64_t bufferLength) "
         },
         {
            "declName": "Flush",
            "declType": " public bool Flush() ",
            "declaration": " public bool Flush() "
         },
         {
            "declName": "Seek",
            "declType": " public void Seek(uint64_t position) ",
            "declaration": " public void Seek(uint64_t position) "
         },
         {
            "declName": "CanRead",
            "declType": " public bool CanRead() const ",
            "declaration": " public bool CanRead() const "
         },
         {
            "declName": "CanWrite",
            "declType": " public bool CanWrite() const ",
            "declaration": " public bool CanWrite() const "
         },
         {
            "declName": "Position",
            "declType": " public uint64_t Position() ",
            "declaration": " public uint64_t Position() "
         },
         {
            "declName": "Size",
            "declType": " public uint64_t Size() ",
            "declaration": " public uint64_t Size() "
         },
         {
            "declName": "Size",
            "declType": " public void Size(uint64_t value) ",
            "declaration": " public void Size(uint64_t value) "
         },
         {
            "declName": "Clone",
            "declType": " std::shared_ptr<Stream> Clone() ",
            "declaration": "public std::shared_ptr<Stream> Clone() "
         }
      ],
      "fileName": "class_mip_stream.md"
   },
   {
      "lines": [
         "# class mip::TemplateDescriptor ",
         "Describes an RMS template.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public std::string TemplateId() const  |  Gets template id.",
         " public std::string Name() const  |  Gets template name.",
         " public std::string Description() const  |  Gets template description.",
         "  ",
         "## Members",
         "  ",
         "### TemplateId",
         "Gets template id.",
         "\n  ",
         "**Returns**: Template id",
         "  ",
         "### Name",
         "Gets template name.",
         "\n  ",
         "**Returns**: Template name",
         "  ",
         "### Description",
         "Gets template description.",
         "\n  ",
         "**Returns**: Template description"
      ],
      "declarations": [
         {
            "declName": "TemplateId",
            "declType": " public std::string TemplateId() const ",
            "declaration": " public std::string TemplateId() const "
         },
         {
            "declName": "Name",
            "declType": " public std::string Name() const ",
            "declaration": " public std::string Name() const "
         },
         {
            "declName": "Description",
            "declType": " public std::string Description() const ",
            "declaration": " public std::string Description() const "
         }
      ],
      "fileName": "class_mip_templatedescriptor.md"
   },
   {
      "lines": [
         "# class mip::UserPolicy ",
         "Represents the policy associated with protected content.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public bool AccessCheck(const std::string& right) const  |  Checks if policy grants user access to specified right.",
         " public UserPolicyType GetType()  |  Gets policy type.",
         " public std::string GetName()  |  Gets policy name.",
         " public std::string GetDescription()  |  Gets policy description.",
         "public std::shared_ptr<TemplateDescriptor> GetTemplateDescriptor()  |  Gets [TemplateDescriptor](class_mip_templatedescriptor.md) for a template-based [UserPolicy](class_mip_userpolicy.md).",
         "public std::shared_ptr<PolicyDescriptor> GetPolicyDescriptor()  |  Gets [PolicyDescriptor](class_mip_policydescriptor.md) for an ad hoc [UserPolicy](class_mip_userpolicy.md).",
         " public std::string GetOwner()  |  Gets email address of content owner.",
         " public std::string GetIssuedTo()  |  Gets user associated with the protection policy.",
         " public bool IsIssuedToOwner()  |  Gets whether or not the current user is the content owner.",
         " public std::string GetContentId()  |  Gets unique identifier for the document/content.",
         " public const mip::AppDataHashMap GetEncryptedAppData()  |  Gets app-specific data that was encrypted.",
         " public const mip::AppDataHashMap GetSignedAppData()  |  Gets the app-specific data that was signed.",
         "public std::chrono::time_point<std::chrono::system_clock> GetContentValidUntil()  |  Gets policy expiration time.",
         " public bool DoesUseDeprecatedAlgorithms()  |  Gets whether or not policy uses deprecated crypto algorithms (ECB) for backward compatibility.",
         " public bool IsAuditedExtractAllowed()  |  Gets whether or not policy grants user 'audited extract' right.",
         "public const std::vector<unsigned char> GetSerializedPolicy()  |  Serialize [UserPolicy](class_mip_userpolicy.md) into a publishing license (PL)",
         "public std::shared_ptr<rmscore::core::ProtectionPolicy> GetImpl()  |  Gets internal derived class implementation of [UserPolicy](class_mip_userpolicy.md).",
         "  ",
         "## Members",
         "  ",
         "### AccessCheck",
         "Checks if policy grants user access to specified right.",
         "\nParameters:  ",
         "* **right**: Right to check",
         "\n",
         "\n  ",
         "**Returns**: Whether or not policy grants user access to specified right",
         "  ",
         "### UserPolicyType",
         "Gets policy type.",
         "\n  ",
         "**Returns**: Policy type",
         "  ",
         "### GetName",
         "Gets policy name.",
         "\n  ",
         "**Returns**: Policy name",
         "  ",
         "### GetDescription",
         "Gets policy description.",
         "\n  ",
         "**Returns**: Policy description",
         "  ",
         "### TemplateDescriptor",
         "Gets [TemplateDescriptor](class_mip_templatedescriptor.md) for a template-based [UserPolicy](class_mip_userpolicy.md).",
         "\n  ",
         "**Returns**: [TemplateDescriptor](class_mip_templatedescriptor.md) if [UserPolicy](class_mip_userpolicy.md) is template-based, else nullptr",
         "  ",
         "### PolicyDescriptor",
         "Gets [PolicyDescriptor](class_mip_policydescriptor.md) for an ad hoc [UserPolicy](class_mip_userpolicy.md).",
         "\n  ",
         "**Returns**: [PolicyDescriptor](class_mip_policydescriptor.md) if [UserPolicy](class_mip_userpolicy.md) is ad hoc, else nullptr",
         "  ",
         "### GetOwner",
         "Gets email address of content owner.",
         "\n  ",
         "**Returns**: Email address of content owner",
         "  ",
         "### GetIssuedTo",
         "Gets user associated with the protection policy.",
         "\n  ",
         "**Returns**: User associated with protection policy",
         "  ",
         "### IsIssuedToOwner",
         "Gets whether or not the current user is the content owner.",
         "\n  ",
         "**Returns**: Whether or not the current user is the content owner",
         "  ",
         "### GetContentId",
         "Gets unique identifier for the document/content.",
         "\n  ",
         "**Returns**: Unique content identifier",
         "  ",
         "### mip::AppDataHashMap",
         "Gets app-specific data that was encrypted.",
         "A [UserPolicy](class_mip_userpolicy.md) may contain a dictionary of app-specific data that was encrypted by the RMS service. This encrypted data is independent of the signed data accessible via [UserPolicy::GetSignedAppData](class_mip_userpolicy.md#getsignedappdata)",
         "  ",
         "### mip::AppDataHashMap",
         "Gets the app-specific data that was signed.",
         "A [UserPolicy](class_mip_userpolicy.md) may contain a dictionary of app-specific data that was signed by the RMS service. This signed data is independent of the encrypted data accessible via [UserPolicy::GetEncryptedAppData](class_mip_userpolicy.md#getencryptedappdata)",
         "  ",
         "### GetContentValidUntil",
         "Gets policy expiration time.",
         "\n  ",
         "**Returns**: Policy expiration time",
         "  ",
         "### DoesUseDeprecatedAlgorithms",
         "Gets whether or not policy uses deprecated crypto algorithms (ECB) for backward compatibility.",
         "\n  ",
         "**Returns**: Whether or not policy uses deprecated crypto algorithms",
         "  ",
         "### IsAuditedExtractAllowed",
         "Gets whether or not policy grants user 'audited extract' right.",
         "\n  ",
         "**Returns**: Whether or not policy grants user 'audited extract' right",
         "  ",
         "### GetSerializedPolicy",
         "Serialize [UserPolicy](class_mip_userpolicy.md) into a publishing license (PL)",
         "\n  ",
         "**Returns**: Serialized [UserPolicy](class_mip_userpolicy.md)",
         "  ",
         "### GetImpl",
         "Gets internal derived class implementation of [UserPolicy](class_mip_userpolicy.md).",
         "\n  ",
         "**Returns**: Derived class implementation of [UserPolicy](class_mip_userpolicy.md)",
         "Internal only"
      ],
      "declarations": [
         {
            "declName": "AccessCheck",
            "declType": " public bool AccessCheck(const std::string& right) const ",
            "declaration": " public bool AccessCheck(const std::string& right) const "
         },
         {
            "declName": "GetType",
            "declType": " public UserPolicyType GetType() ",
            "declaration": " public UserPolicyType GetType() "
         },
         {
            "declName": "GetName",
            "declType": " public std::string GetName() ",
            "declaration": " public std::string GetName() "
         },
         {
            "declName": "GetDescription",
            "declType": " public std::string GetDescription() ",
            "declaration": " public std::string GetDescription() "
         },
         {
            "declName": "GetTemplateDescriptor",
            "declType": " std::shared_ptr<TemplateDescriptor> GetTemplateDescriptor() ",
            "declaration": "public std::shared_ptr<TemplateDescriptor> GetTemplateDescriptor() "
         },
         {
            "declName": "GetPolicyDescriptor",
            "declType": " std::shared_ptr<PolicyDescriptor> GetPolicyDescriptor() ",
            "declaration": "public std::shared_ptr<PolicyDescriptor> GetPolicyDescriptor() "
         },
         {
            "declName": "GetOwner",
            "declType": " public std::string GetOwner() ",
            "declaration": " public std::string GetOwner() "
         },
         {
            "declName": "GetIssuedTo",
            "declType": " public std::string GetIssuedTo() ",
            "declaration": " public std::string GetIssuedTo() "
         },
         {
            "declName": "IsIssuedToOwner",
            "declType": " public bool IsIssuedToOwner() ",
            "declaration": " public bool IsIssuedToOwner() "
         },
         {
            "declName": "GetContentId",
            "declType": " public std::string GetContentId() ",
            "declaration": " public std::string GetContentId() "
         },
         {
            "declName": "GetEncryptedAppData",
            "declType": " public const mip::AppDataHashMap GetEncryptedAppData() ",
            "declaration": " public const mip::AppDataHashMap GetEncryptedAppData() "
         },
         {
            "declName": "GetSignedAppData",
            "declType": " public const mip::AppDataHashMap GetSignedAppData() ",
            "declaration": " public const mip::AppDataHashMap GetSignedAppData() "
         },
         {
            "declName": "GetContentValidUntil",
            "declType": " std::chrono::time_point<std::chrono::system_clock> GetContentValidUntil() ",
            "declaration": "public std::chrono::time_point<std::chrono::system_clock> GetContentValidUntil() "
         },
         {
            "declName": "DoesUseDeprecatedAlgorithms",
            "declType": " public bool DoesUseDeprecatedAlgorithms() ",
            "declaration": " public bool DoesUseDeprecatedAlgorithms() "
         },
         {
            "declName": "IsAuditedExtractAllowed",
            "declType": " public bool IsAuditedExtractAllowed() ",
            "declaration": " public bool IsAuditedExtractAllowed() "
         },
         {
            "declName": "GetSerializedPolicy",
            "declType": " const std::vector<unsigned char> GetSerializedPolicy() ",
            "declaration": "public const std::vector<unsigned char> GetSerializedPolicy() "
         },
         {
            "declName": "GetImpl",
            "declType": " std::shared_ptr<rmscore::core::ProtectionPolicy> GetImpl() ",
            "declaration": "public std::shared_ptr<rmscore::core::ProtectionPolicy> GetImpl() "
         }
      ],
      "fileName": "class_mip_userpolicy.md"
   },
   {
      "lines": [
         "# class mip::UserRights ",
         "Represents a group of users and the rights associated with them.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public UserRights(const UserList& users, const RightList& rights)  |  [UserRights](class_mip_userrights.md) constructor.",
         " public const UserList& Users() const  |  Gets users associated with a set of rights.",
         " public const RightList& Rights() const  |  Gets rights associated with a group of users.",
         "  ",
         "## Members",
         "  ",
         "### UserRights",
         "[UserRights](class_mip_userrights.md) constructor.",
         "\nParameters:  ",
         "* **users**: Group of users that share the same rights ",
         "\n",
         "* **rights**: Rights shared by group of users",
         "\n",
         "  ",
         "### UserList",
         "Gets users associated with a set of rights.",
         "\n  ",
         "**Returns**: Users associated with a set of rights",
         "  ",
         "### RightList",
         "Gets rights associated with a group of users.",
         "\n  ",
         "**Returns**: Rights associated with a group of users"
      ],
      "declarations": [
         {
            "declName": "UserRights",
            "declType": " public inline UserRights(const UserList& users, const RightList& rights) ",
            "declaration": " public UserRights(const UserList& users, const RightList& rights) "
         },
         {
            "declName": "Users",
            "declType": " public inline const UserList& Users() const ",
            "declaration": " public const UserList& Users() const "
         },
         {
            "declName": "Rights",
            "declType": " public inline const RightList& Rights() const ",
            "declaration": " public const RightList& Rights() const "
         }
      ],
      "fileName": "class_mip_userrights.md"
   },
   {
      "lines": [
         "# class mip::UserRoles ",
         "Represents a group of users and the roles associated with them.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public MIP_EXPORT UserRoles(const UserList& users, const RoleList& roles)  |  [UserRoles](class_mip_userroles.md) constructor.",
         " public const UserList& Users() const  |  Gets users associated with a set of roles.",
         " public const RoleList& Roles() const  |  Gets roles associated with a group of users.",
         "  ",
         "## Members",
         "  ",
         "### UserRoles",
         "[UserRoles](class_mip_userroles.md) constructor.",
         "\nParameters:  ",
         "* **users**: Group of users that share the same roles ",
         "\n",
         "* **roles**: [Roles](class_mip_roles.md) shared by group of users",
         "\n",
         "  ",
         "### UserList",
         "Gets users associated with a set of roles.",
         "\n  ",
         "**Returns**: Users associated with a set of roles",
         "  ",
         "### RoleList",
         "Gets roles associated with a group of users.",
         "\n  ",
         "**Returns**: [Roles](class_mip_roles.md) associated with a group of users"
      ],
      "declarations": [
         {
            "declName": "UserRoles",
            "declType": " public MIP_EXPORT UserRoles(const UserList& users, const RoleList& roles) ",
            "declaration": " public MIP_EXPORT UserRoles(const UserList& users, const RoleList& roles) "
         },
         {
            "declName": "Users",
            "declType": " public inline const UserList& Users() const ",
            "declaration": " public const UserList& Users() const "
         },
         {
            "declName": "Roles",
            "declType": " public inline const RoleList& Roles() const ",
            "declaration": " public const RoleList& Roles() const "
         }
      ],
      "fileName": "class_mip_userroles.md"
   },
   {
      "lines": [
         "# class mip::FileProfile::Observer ",
         "[Observer](class_mip_fileprofile_observer.md) interface for clients to get notifications for profile related events.",
         "If an *Error event occurs, error object holds inside [mip::Error](class_mip_error.md) class. ",
         "Client should not call the engine back on the thread that calls the observer.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public virtual ~Observer()  | _Not yet documented._",
         "public virtual void OnLoadSuccess(const std::shared_ptr<mip::FileProfile>& profile, const std::shared_ptr<void>& context)  |  Called when profile was loaded successfully.",
         "public virtual void OnLoadFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context)  |  Called when loading a profile caused an error.",
         "public virtual void OnListEnginesSuccess(const std::vector<std::string>& engineIds, const std::shared_ptr<void>& context)  |  Called when list of engines was generated successfully.",
         "public virtual void OnListEnginesError(const std::exception_ptr& error, const std::shared_ptr<void>& context)  |  Called when listing engines caused an error.",
         "public virtual void OnUnloadEngineSuccess(const std::shared_ptr<void>& context)  |  Called when an engine was unloaded successfully.",
         "public virtual void OnUnloadEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context)  |  Called when unloading an engine caused an error.",
         "public virtual void OnAddEngineSuccess(const std::shared_ptr<mip::FileEngine>& engine, const std::shared_ptr<void>& context)  |  Called when a new engine was added successfully.",
         "public virtual void OnAddEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context)  |  Called when adding a new engine caused an error.",
         "public virtual void OnDeleteEngineSuccess(const std::shared_ptr<void>& context)  |  Called when an engine was deleted successfully.",
         "public virtual void OnDeleteEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context)  |  Called when deleting an engine caused an error.",
         " public virtual void OnPolicyChanged(const std::string& engineId)  |  Called when the policy has changed for the engine with the given id.",
         " protected Observer()  | _Not yet documented._",
         "  ",
         "## Members",
         "  ",
         "### ~Observer",
         "_Not documented yet._\n",
         "  ",
         "### OnLoadSuccess",
         "Called when profile was loaded successfully.",
         "  ",
         "### OnLoadFailure",
         "Called when loading a profile caused an error.",
         "  ",
         "### OnListEnginesSuccess",
         "Called when list of engines was generated successfully.",
         "  ",
         "### OnListEnginesError",
         "Called when listing engines caused an error.",
         "  ",
         "### OnUnloadEngineSuccess",
         "Called when an engine was unloaded successfully.",
         "  ",
         "### OnUnloadEngineError",
         "Called when unloading an engine caused an error.",
         "  ",
         "### OnAddEngineSuccess",
         "Called when a new engine was added successfully.",
         "  ",
         "### OnAddEngineError",
         "Called when adding a new engine caused an error.",
         "  ",
         "### OnDeleteEngineSuccess",
         "Called when an engine was deleted successfully.",
         "  ",
         "### OnDeleteEngineError",
         "Called when deleting an engine caused an error.",
         "  ",
         "### OnPolicyChanged",
         "Called when the policy has changed for the engine with the given id.",
         "  ",
         "### Observer",
         "_Not documented yet._\n"
      ],
      "declarations": [
         {
            "declName": "~Observer",
            "declType": " public inline virtual ~Observer() ",
            "declaration": " public virtual ~Observer() "
         },
         {
            "declName": "OnLoadSuccess",
            "declType": " inline virtual void OnLoadSuccess(const std::shared_ptr<mip::FileProfile>& profile, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnLoadSuccess(const std::shared_ptr<mip::FileProfile>& profile, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnLoadFailure",
            "declType": " inline virtual void OnLoadFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnLoadFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnListEnginesSuccess",
            "declType": " inline virtual void OnListEnginesSuccess(const std::vector<std::string>& engineIds, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnListEnginesSuccess(const std::vector<std::string>& engineIds, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnListEnginesError",
            "declType": " inline virtual void OnListEnginesError(const std::exception_ptr& error, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnListEnginesError(const std::exception_ptr& error, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnUnloadEngineSuccess",
            "declType": " inline virtual void OnUnloadEngineSuccess(const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnUnloadEngineSuccess(const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnUnloadEngineError",
            "declType": " inline virtual void OnUnloadEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnUnloadEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnAddEngineSuccess",
            "declType": " inline virtual void OnAddEngineSuccess(const std::shared_ptr<mip::FileEngine>& engine, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnAddEngineSuccess(const std::shared_ptr<mip::FileEngine>& engine, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnAddEngineError",
            "declType": " inline virtual void OnAddEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnAddEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnDeleteEngineSuccess",
            "declType": " inline virtual void OnDeleteEngineSuccess(const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnDeleteEngineSuccess(const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnDeleteEngineError",
            "declType": " inline virtual void OnDeleteEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnDeleteEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnPolicyChanged",
            "declType": " public inline virtual void OnPolicyChanged(const std::string& engineId) ",
            "declaration": " public virtual void OnPolicyChanged(const std::string& engineId) "
         },
         {
            "declName": "Observer",
            "declType": " protected inline Observer() ",
            "declaration": " protected Observer() "
         }
      ],
      "fileName": "class_mip_fileprofile_observer.md"
   },
   {
      "lines": [
         "# class mip::Profile::Observer ",
         "[Observer](class_mip_profile_observer.md) interface for clients to get notifications for profile related events.",
         "If an *Error event occurs, error object holds inside [mip::Error](class_mip_error.md) class. ",
         "Client should not call the engine back on the thread that calls the observer.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "public virtual void OnLoadSuccess(const std::shared_ptr<Profile>& profile, const std::shared_ptr<void>& context)  |  Called when profile was loaded successfully.",
         "public virtual void OnLoadFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context)  |  Called when loading a profile caused an error.",
         "public virtual void OnListEnginesSuccess(const std::vector<std::string>& engineIds, const std::shared_ptr<void>& context)  |  Called when list of engines was generated successfully.",
         "public virtual void OnListEnginesError(const std::exception_ptr& error, const std::shared_ptr<void>& context)  |  Called when listing engines caused an error.",
         "public virtual void OnUnloadEngineSuccess(const std::shared_ptr<void>& context)  |  Called when an engine was unloaded successfully.",
         "public virtual void OnUnloadEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context)  |  Called when unloading an engine caused an error.",
         "public virtual void OnAddEngineSuccess(const std::shared_ptr<PolicyEngine>& engine, const std::shared_ptr<void>& context)  |  Called when a new engine was added successfully.",
         "public virtual void OnAddEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context)  |  Called when adding a new engine caused an error.",
         "public virtual void OnDeleteEngineSuccess(const std::shared_ptr<void>& context)  |  Called when an engine was deleted successfully.",
         "public virtual void OnDeleteEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context)  |  Called when deleting an engine caused an error.",
         " public virtual void OnPolicyChanged(const std::string& engineId)  |  Called when the policy has changed for the engine with the given id.",
         "  ",
         "## Members",
         "  ",
         "### OnLoadSuccess",
         "Called when profile was loaded successfully.",
         "\nParameters:  ",
         "* **profile**: the current profile used to start the operation. ",
         "\n",
         "* **context**: the context passed to the operation.",
         "\n",
         "  ",
         "### OnLoadFailure",
         "Called when loading a profile caused an error.",
         "\nParameters:  ",
         "* **error**: the error that cause the load operation to fail. ",
         "\n",
         "* **context**: the context passed to the operation.",
         "\n",
         "  ",
         "### OnListEnginesSuccess",
         "Called when list of engines was generated successfully.",
         "\nParameters:  ",
         "* **engineIds**: a list of engine ids the are available. ",
         "\n",
         "* **context**: the context passed to the operation.",
         "\n",
         "  ",
         "### OnListEnginesError",
         "Called when listing engines caused an error.",
         "\nParameters:  ",
         "* **error**: the error that cause the list engine operation to fail. ",
         "\n",
         "* **context**: the context passed to the operation.",
         "\n",
         "  ",
         "### OnUnloadEngineSuccess",
         "Called when an engine was unloaded successfully.",
         "\nParameters:  ",
         "* **context**: the context passed to the operation.",
         "\n",
         "  ",
         "### OnUnloadEngineError",
         "Called when unloading an engine caused an error.",
         "\nParameters:  ",
         "* **error**: the error that cause the unload engine operation to fail. ",
         "\n",
         "* **context**: the context passed to the operation.",
         "\n",
         "  ",
         "### OnAddEngineSuccess",
         "Called when a new engine was added successfully.",
         "  ",
         "### OnAddEngineError",
         "Called when adding a new engine caused an error.",
         "\nParameters:  ",
         "* **error**: the error that cause the add engine operation to fail. ",
         "\n",
         "* **context**: the context passed to the operation.",
         "\n",
         "  ",
         "### OnDeleteEngineSuccess",
         "Called when an engine was deleted successfully.",
         "\nParameters:  ",
         "* **context**: the context passed to the operation.",
         "\n",
         "  ",
         "### OnDeleteEngineError",
         "Called when deleting an engine caused an error.",
         "\nParameters:  ",
         "* **error**: the error that cause the delete engine operation to fail. ",
         "\n",
         "* **context**: the context passed to the operation.",
         "\n",
         "  ",
         "### OnPolicyChanged",
         "Called when the policy has changed for the engine with the given id.",
         "\nParameters:  ",
         "* **engineId**: the engine ",
         "\n",
         "To load the new policy it is necessary to call AddEngineAsync again with the engine Id given."
      ],
      "declarations": [
         {
            "declName": "OnLoadSuccess",
            "declType": " inline virtual void OnLoadSuccess(const std::shared_ptr<Profile>& profile, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnLoadSuccess(const std::shared_ptr<Profile>& profile, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnLoadFailure",
            "declType": " inline virtual void OnLoadFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnLoadFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnListEnginesSuccess",
            "declType": " inline virtual void OnListEnginesSuccess(const std::vector<std::string>& engineIds, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnListEnginesSuccess(const std::vector<std::string>& engineIds, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnListEnginesError",
            "declType": " inline virtual void OnListEnginesError(const std::exception_ptr& error, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnListEnginesError(const std::exception_ptr& error, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnUnloadEngineSuccess",
            "declType": " inline virtual void OnUnloadEngineSuccess(const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnUnloadEngineSuccess(const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnUnloadEngineError",
            "declType": " inline virtual void OnUnloadEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnUnloadEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnAddEngineSuccess",
            "declType": " inline virtual void OnAddEngineSuccess(const std::shared_ptr<PolicyEngine>& engine, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnAddEngineSuccess(const std::shared_ptr<PolicyEngine>& engine, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnAddEngineError",
            "declType": " inline virtual void OnAddEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnAddEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnDeleteEngineSuccess",
            "declType": " inline virtual void OnDeleteEngineSuccess(const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnDeleteEngineSuccess(const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnDeleteEngineError",
            "declType": " inline virtual void OnDeleteEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnDeleteEngineError(const std::exception_ptr& error, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnPolicyChanged",
            "declType": " public inline virtual void OnPolicyChanged(const std::string& engineId) ",
            "declaration": " public virtual void OnPolicyChanged(const std::string& engineId) "
         }
      ],
      "fileName": "class_mip_profile_observer.md"
   },
   {
      "lines": [
         "# class mip::ProtectionProfile::Observer ",
         "Interface that receives notifications related to [ProtectionProfile](class_mip_protectionprofile.md).",
         "This interface must by implemented by applications using the protection SDK",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "public virtual void OnLoadSuccess(const std::shared_ptr<ProtectionProfile>& profile, const std::shared_ptr<void>& context)  |  Called when profile was loaded successfully.",
         "public virtual void OnLoadFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context)  |  Called when loading a profile caused an error.",
         "  ",
         "## Members",
         "  ",
         "### OnLoadSuccess",
         "Called when profile was loaded successfully.",
         "\nParameters:  ",
         "* **profile**: A reference to the newly-created [ProtectionProfile](class_mip_protectionprofile.md)",
         "\n",
         "* **context**: The same context that was passed to [ProtectionProfile::LoadAsync](class_mip_protectionprofile.md#loadasync)",
         "\n",
         "An application can pass any type of context (e.g. std::promise, std::function, etc.) to [ProtectionProfile::LoadAsync](class_mip_protectionprofile.md#loadasync) and that same context will be forwarded as-is to [ProtectionProfile::Observer::OnLoadSuccess](class_mip_protectionprofile_observer.md#onloadsuccess) or [ProtectionProfile::Observer::OnLoadFailure](class_mip_protectionprofile_observer.md#onloadfailure)",
         "  ",
         "### OnLoadFailure",
         "Called when loading a profile caused an error.",
         "\nParameters:  ",
         "* **error**: [Error](class_mip_error.md) that occured while loading ",
         "\n",
         "* **context**: The same context that was passed to [ProtectionProfile::LoadAsync](class_mip_protectionprofile.md#loadasync)",
         "\n",
         "An application can pass any type of context (e.g. std::promise, std::function, etc.) to [ProtectionProfile::LoadAsync](class_mip_protectionprofile.md#loadasync) and that same context will be forwarded as-is to [ProtectionProfile::Observer::OnLoadSuccess](class_mip_protectionprofile_observer.md#onloadsuccess) or [ProtectionProfile::Observer::OnLoadFailure](class_mip_protectionprofile_observer.md#onloadfailure)"
      ],
      "declarations": [
         {
            "declName": "OnLoadSuccess",
            "declType": " inline virtual void OnLoadSuccess(const std::shared_ptr<ProtectionProfile>& profile, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnLoadSuccess(const std::shared_ptr<ProtectionProfile>& profile, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnLoadFailure",
            "declType": " inline virtual void OnLoadFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context) ",
            "declaration": "public virtual void OnLoadFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context) "
         }
      ],
      "fileName": "class_mip_protectionprofile_observer.md"
   },
   {
      "lines": [
         "# class mip::FileHandler::Observer ",
         "[Observer](class_mip_filehandler_observer.md) interface for clients to get notifications for file handler related events.",
         "If an *Error event occurs, error object holds inside [mip::Error](class_mip_error.md) class. ",
         "Client should not call the engine back on the thread that calls the observer.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public virtual ~Observer()  | _Not yet documented._",
         "public void OnGetLabelSuccess(const std::shared_ptr<ContentLabel>& label, const std::shared_ptr<void>& context)  |  Called when the label is retrieved (from the file) successfully.",
         "public void OnGetLabelFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context)  |  Called when retrieving the label (from the file) failed due to an error.",
         "public void OnGetProtectionSuccess(const std::shared_ptr<UserPolicy>& userPolicy, const std::shared_ptr<void>& context)  |  Called when the protection policy is retrieved (from the file) successfully.",
         "public void OnGetProtectionFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context)  |  Called when retrieving the protection policy (from the file) failed due to an error.",
         "public void OnCommitSuccess(bool commited, const std::shared_ptr<void>& context)  |  Called when committing the changes to the file were successful.",
         "public void OnCommitFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context)  |  Called when committing the changes to the file failed due to an error.",
         " protected Observer()  | _Not yet documented._",
         "  ",
         "## Members",
         "  ",
         "### ~Observer",
         "_Not documented yet._\n",
         "  ",
         "### OnGetLabelSuccess",
         "Called when the label is retrieved (from the file) successfully.",
         "  ",
         "### OnGetLabelFailure",
         "Called when retrieving the label (from the file) failed due to an error.",
         "  ",
         "### OnGetProtectionSuccess",
         "Called when the protection policy is retrieved (from the file) successfully.",
         "  ",
         "### OnGetProtectionFailure",
         "Called when retrieving the protection policy (from the file) failed due to an error.",
         "  ",
         "### OnCommitSuccess",
         "Called when committing the changes to the file were successful.",
         "  ",
         "### OnCommitFailure",
         "Called when committing the changes to the file failed due to an error.",
         "  ",
         "### Observer",
         "_Not documented yet._\n"
      ],
      "declarations": [
         {
            "declName": "~Observer",
            "declType": " public inline virtual ~Observer() ",
            "declaration": " public virtual ~Observer() "
         },
         {
            "declName": "OnGetLabelSuccess",
            "declType": " void OnGetLabelSuccess(const std::shared_ptr<ContentLabel>& label, const std::shared_ptr<void>& context) ",
            "declaration": "public void OnGetLabelSuccess(const std::shared_ptr<ContentLabel>& label, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnGetLabelFailure",
            "declType": " void OnGetLabelFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context) ",
            "declaration": "public void OnGetLabelFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnGetProtectionSuccess",
            "declType": " void OnGetProtectionSuccess(const std::shared_ptr<UserPolicy>& userPolicy, const std::shared_ptr<void>& context) ",
            "declaration": "public void OnGetProtectionSuccess(const std::shared_ptr<UserPolicy>& userPolicy, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnGetProtectionFailure",
            "declType": " void OnGetProtectionFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context) ",
            "declaration": "public void OnGetProtectionFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnCommitSuccess",
            "declType": " void OnCommitSuccess(bool commited, const std::shared_ptr<void>& context) ",
            "declaration": "public void OnCommitSuccess(bool commited, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "OnCommitFailure",
            "declType": " void OnCommitFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context) ",
            "declaration": "public void OnCommitFailure(const std::exception_ptr& error, const std::shared_ptr<void>& context) "
         },
         {
            "declName": "Observer",
            "declType": " protected inline Observer() ",
            "declaration": " protected Observer() "
         }
      ],
      "fileName": "class_mip_filehandler_observer.md"
   },
   {
      "lines": [
         "# class mip::FileEngine::Settings ",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public Settings(const std::string& id, const std::string& clientData, const std::string& locale)  |  Creates an instance with the given parameters.",
         " public Settings(const Identity& identity, const std::string& clientData, const std::string& locale)  |  Creates an instance with the given parameters.",
         " public const std::string& GetId() const  |  Returns the engine Id.",
         " public const Identity& GetIdentity() const  |  Returns the engine Identity.",
         " public void SetIdentity(const Identity& identity)  |  Sets the engine identity.",
         " public const std::string& GetClientData() const  |  Returns the engine client data.",
         " public const std::string& GetLocale() const  |  Return the engine locale.",
         "public void SetCustomSettings(const std::vector<std::pair<std::string, std::string>>& value)  |  Sets a list of name/value pairs used for testing and experimentation.",
         "public const std::vector<std::pair<std::string, std::string>>& GetCustomSettings() const  |  Gets a list of name/value pairs used for testing and experimentation.",
         " public void SetSessionId(const std::string& sessionId)  |  Sets the engine session id.",
         " public const std::string& GetSessionId() const  |  Return the engine session id.",
         "  ",
         "## Members",
         "  ",
         "### Settings",
         "Creates an instance with the given parameters.",
         "Use this to create [Settings](class_mip_fileengine_settings.md) to call LoadEngineAsync to load an existing engine (previously added via AddEngineAsync).",
         "\nParameters:  ",
         "* **id**: Set it to the unique engine id generated by AddEngineAsync.",
         "\n",
         "  ",
         "### Settings",
         "Creates an instance with the given parameters.",
         "Use this to create [Settings](class_mip_fileengine_settings.md) to call AddEngineAsync to add a new engine.",
         "\nParameters:  ",
         "* **identity**: Identity info of the user for whom the engine needs to be added.",
         "\n",
         "  ",
         "### GetId",
         "Returns the engine Id.",
         "  ",
         "### GetIdentity",
         "Returns the engine Identity.",
         "  ",
         "### SetIdentity",
         "Sets the engine identity.",
         "  ",
         "### GetClientData",
         "Returns the engine client data.",
         "  ",
         "### GetLocale",
         "Return the engine locale.",
         "  ",
         "### SetCustomSettings",
         "Sets a list of name/value pairs used for testing and experimentation.",
         "  ",
         "### GetCustomSettings",
         "Gets a list of name/value pairs used for testing and experimentation.",
         "  ",
         "### SetSessionId",
         "Sets the engine session id.",
         "  ",
         "### GetSessionId",
         "Return the engine session id."
      ],
      "declarations": [
         {
            "declName": "Settings",
            "declType": " public inline Settings(const std::string& id, const std::string& clientData, const std::string& locale) ",
            "declaration": " public Settings(const std::string& id, const std::string& clientData, const std::string& locale) "
         },
         {
            "declName": "Settings",
            "declType": " public inline Settings(const Identity& identity, const std::string& clientData, const std::string& locale) ",
            "declaration": " public Settings(const Identity& identity, const std::string& clientData, const std::string& locale) "
         },
         {
            "declName": "GetId",
            "declType": " public inline const std::string& GetId() const ",
            "declaration": " public const std::string& GetId() const "
         },
         {
            "declName": "GetIdentity",
            "declType": " public inline const Identity& GetIdentity() const ",
            "declaration": " public const Identity& GetIdentity() const "
         },
         {
            "declName": "SetIdentity",
            "declType": " public inline void SetIdentity(const Identity& identity) ",
            "declaration": " public void SetIdentity(const Identity& identity) "
         },
         {
            "declName": "GetClientData",
            "declType": " public inline const std::string& GetClientData() const ",
            "declaration": " public const std::string& GetClientData() const "
         },
         {
            "declName": "GetLocale",
            "declType": " public inline const std::string& GetLocale() const ",
            "declaration": " public const std::string& GetLocale() const "
         },
         {
            "declName": "SetCustomSettings",
            "declType": " inline void SetCustomSettings(const std::vector<std::pair<std::string, std::string>>& value) ",
            "declaration": "public void SetCustomSettings(const std::vector<std::pair<std::string, std::string>>& value) "
         },
         {
            "declName": "GetCustomSettings",
            "declType": " inline const std::vector<std::pair<std::string, std::string>>& GetCustomSettings() const ",
            "declaration": "public const std::vector<std::pair<std::string, std::string>>& GetCustomSettings() const "
         },
         {
            "declName": "SetSessionId",
            "declType": " public inline void SetSessionId(const std::string& sessionId) ",
            "declaration": " public void SetSessionId(const std::string& sessionId) "
         },
         {
            "declName": "GetSessionId",
            "declType": " public inline const std::string& GetSessionId() const ",
            "declaration": " public const std::string& GetSessionId() const "
         }
      ],
      "fileName": "class_mip_fileengine_settings.md"
   },
   {
      "lines": [
         "# class mip::PolicyEngine::Settings ",
         "An instance of this class with the approprieted parameters should be provide to initiate an engine.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public Settings(const std::string& id, const std::string& clientData, const std::string& locale)  |  Construct an instance with the given parameters. Use this to create [Settings](class_mip_policyengine_settings.md) to call LoadEngineAsync to load an existing engine.",
         " public Settings(const Identity& identity, const std::string& clientData, const std::string& locale)  |  Use this to create [Settings](class_mip_policyengine_settings.md) to call AddEngineAsync to add a new engine.",
         " public const std::string& GetId() const  |  Get the engine id.",
         " public void SetId(const std::string& id)  |  Set the engine id.",
         " public const Identity& GetIdentity() const  |  Get the Identity object.",
         " public void SetIdentity(const Identity& identity)  |  Set the Identity object.",
         " public const std::string& GetClientData() const  |  Get the Client Data set in the settings.",
         " public void SetClientData(const std::string& clientData)  |  Set the Client Data string.",
         " public const std::string& GetLocale() const  |  Get the Locale set in the settings.",
         "public void SetCustomSettings(const std::vector<std::pair<std::string, std::string>>& customSettings)  |  Set the custom settings, used for feature gating and testing.",
         "public const std::vector<std::pair<std::string, std::string>>& GetCustomSettings() const  |  Get the custom settings, used for feature gating and testing.",
         " public void SetSessionId(const std::string& sessionId)  |  Set the session id, used for client defined telementry.",
         " public const std::string& GetSessionId() const  |  Get the session id, a unique identifier.",
         "  ",
         "## Members",
         "  ",
         "### Settings",
         "Construct an instance with the given parameters. Use this to create [Settings](class_mip_policyengine_settings.md) to call LoadEngineAsync to load an existing engine.",
         "\nParameters:  ",
         "* **id**: Set it to the unique engine id generated by AddEngineAsync or one self-generated. When loading an existing engine re-use the id else a new engine will be created. ",
         "\n",
         "* **clientData**: customizable client data that can be stored with the engine when unloaded, can be retrieve from a loaded engine. ",
         "\n",
         "* **locale**: engine localizable output will be provided in this locale, default \"en-US\".",
         "\n",
         "  ",
         "### Settings",
         "Use this to create [Settings](class_mip_policyengine_settings.md) to call AddEngineAsync to add a new engine.",
         "\nParameters:  ",
         "* **identity**: unique identifier of the user for whom the engine needs to be added. ",
         "\n",
         "* **clientData**: customizable client data that can be stored with the engine when unloaded, can be retrieve from a loaded engine. ",
         "\n",
         "* **locale**: engine localizable output will be provided in this locale, default \"en-US\".",
         "\n",
         "  ",
         "### GetId",
         "Get the engine id.",
         "\n  ",
         "**Returns**: A unique string identifying the engine.",
         "  ",
         "### SetId",
         "Set the engine id.",
         "\nParameters:  ",
         "* **id**: engine id.",
         "\n",
         "  ",
         "### GetIdentity",
         "Get the Identity object.",
         "\n  ",
         "**Returns**: A refrence to the identity in the settings object. ",
         "  ",
         "**See also**: mip::Identity",
         "  ",
         "### SetIdentity",
         "Set the Identity object.",
         "\nParameters:  ",
         "* **identity**: the unique identity of a user. ",
         "\n",
         "  ",
         "**See also**: mip::Identity",
         "  ",
         "### GetClientData",
         "Get the Client Data set in the settings.",
         "\n  ",
         "**Returns**: A string of data specified by the client.",
         "  ",
         "### SetClientData",
         "Set the Client Data string.",
         "\nParameters:  ",
         "* **clientData**: user specified data.",
         "\n",
         "  ",
         "### GetLocale",
         "Get the Locale set in the settings.",
         "\n  ",
         "**Returns**: The locale.",
         "  ",
         "### SetCustomSettings",
         "Set the custom settings, used for feature gating and testing.",
         "\nParameters:  ",
         "* **customSettings**: List of name/value pairs.",
         "\n",
         "  ",
         "### GetCustomSettings",
         "Get the custom settings, used for feature gating and testing.",
         "\n  ",
         "**Returns**: List of name/value pairs.",
         "  ",
         "### SetSessionId",
         "Set the session id, used for client defined telementry.",
         "\nParameters:  ",
         "* **sessionId**: a unique string that connects telemetry events.",
         "\n",
         "  ",
         "### GetSessionId",
         "Get the session id, a unique identifier.",
         "\n  ",
         "**Returns**: The session id."
      ],
      "declarations": [
         {
            "declName": "Settings",
            "declType": " public inline Settings(const std::string& id, const std::string& clientData, const std::string& locale) ",
            "declaration": " public Settings(const std::string& id, const std::string& clientData, const std::string& locale) "
         },
         {
            "declName": "Settings",
            "declType": " public inline Settings(const Identity& identity, const std::string& clientData, const std::string& locale) ",
            "declaration": " public Settings(const Identity& identity, const std::string& clientData, const std::string& locale) "
         },
         {
            "declName": "GetId",
            "declType": " public inline const std::string& GetId() const ",
            "declaration": " public const std::string& GetId() const "
         },
         {
            "declName": "SetId",
            "declType": " public inline void SetId(const std::string& id) ",
            "declaration": " public void SetId(const std::string& id) "
         },
         {
            "declName": "GetIdentity",
            "declType": " public inline const Identity& GetIdentity() const ",
            "declaration": " public const Identity& GetIdentity() const "
         },
         {
            "declName": "SetIdentity",
            "declType": " public inline void SetIdentity(const Identity& identity) ",
            "declaration": " public void SetIdentity(const Identity& identity) "
         },
         {
            "declName": "GetClientData",
            "declType": " public inline const std::string& GetClientData() const ",
            "declaration": " public const std::string& GetClientData() const "
         },
         {
            "declName": "SetClientData",
            "declType": " public inline void SetClientData(const std::string& clientData) ",
            "declaration": " public void SetClientData(const std::string& clientData) "
         },
         {
            "declName": "GetLocale",
            "declType": " public inline const std::string& GetLocale() const ",
            "declaration": " public const std::string& GetLocale() const "
         },
         {
            "declName": "SetCustomSettings",
            "declType": " inline void SetCustomSettings(const std::vector<std::pair<std::string, std::string>>& customSettings) ",
            "declaration": "public void SetCustomSettings(const std::vector<std::pair<std::string, std::string>>& customSettings) "
         },
         {
            "declName": "GetCustomSettings",
            "declType": " inline const std::vector<std::pair<std::string, std::string>>& GetCustomSettings() const ",
            "declaration": "public const std::vector<std::pair<std::string, std::string>>& GetCustomSettings() const "
         },
         {
            "declName": "SetSessionId",
            "declType": " public inline void SetSessionId(const std::string& sessionId) ",
            "declaration": " public void SetSessionId(const std::string& sessionId) "
         },
         {
            "declName": "GetSessionId",
            "declType": " public inline const std::string& GetSessionId() const ",
            "declaration": " public const std::string& GetSessionId() const "
         }
      ],
      "fileName": "class_mip_policyengine_settings.md"
   },
   {
      "lines": [
         "# class mip::FileProfile::Settings ",
         "[Settings](class_fileprofile_settings.md) used by [FileProfile](class_mip_fileprofile.md) during its creation and throughout its lifetime.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "public Settings(const std::string& path, bool useInMemoryStorage, std::shared_ptr<AuthDelegate> authDelegate, std::shared_ptr<Observer> observer, const ApplicationInfo& applicationInfo)  |  [FileProfile::Settings](class_fileprofile_settings.md) constructor.",
         " public const std::string& GetPath() const  |  Gets the path under which logging, telemetry, and other persistent state is stored.",
         " public bool GetUseInMemoryStorage() const  |  Gets whether or not all state should be stored in memory (as opposed to on disk)",
         "public std::shared_ptr<AuthDelegate> GetAuthDelegate() const  |  Gets the auth delegate used for acquiring authentication tokens.",
         "public std::shared_ptr<Observer> GetObserver() const  |  Gets the observer which receieves notifications of events related to [FileProfile](class_mip_fileprofile.md).",
         " public const ApplicationInfo GetApplicationInfo() const  |  Gets info regarding application that is consuming the SDK.",
         " public bool GetSkipTelemetryInit() const  |  Gets whether or not telemetry initialization should be skipped.",
         " public void SetSkipTelemetryInit()  |  Disables telemetry initialization.",
         " public void OptOutTelemetry()  |  Opts out of all telemetry gathering.",
         " public bool IsTelemetryOptedOut() const  |  Gets whether or not telemetry gathering should be disabled.",
         " public void SetSessionId(const std::string& sessionId)  |  Sets the session id.",
         " public const std::string& GetSessionId() const  |  Gets the session id.",
         "  ",
         "## Members",
         "  ",
         "### Settings",
         "[FileProfile::Settings](class_fileprofile_settings.md) constructor.",
         "\nParameters:  ",
         "* **path**: File path under which logging, telemetry, and other persistent state is stored ",
         "\n",
         "* **useInMemoryStorage**: Whether or not all state should be stored in memory (as opposed to on disk) ",
         "\n",
         "* **authDelegate**: Auth delegate used for acquiring authentication tokens ",
         "\n",
         "* **observer**: [Observer](class_mip_fileprofile_observer.md) instance which will receive notifications of events related to [FileProfile](class_mip_fileprofile.md)",
         "\n",
         "* **applicationInfo**: Info regarding application that is consuming the SDK",
         "\n",
         "  ",
         "### GetPath",
         "Gets the path under which logging, telemetry, and other persistent state is stored.",
         "\n  ",
         "**Returns**: Path under which logging, telemetry, and other persistent state is stored",
         "  ",
         "### GetUseInMemoryStorage",
         "Gets whether or not all state should be stored in memory (as opposed to on disk)",
         "\n  ",
         "**Returns**: Whether or not all state should be stored in memory (as opposed to on disk)",
         "  ",
         "### GetAuthDelegate",
         "Gets the auth delegate used for acquiring authentication tokens.",
         "\n  ",
         "**Returns**: Auth delegate used for acquiring authentication tokens",
         "  ",
         "### Observer",
         "Gets the observer which receieves notifications of events related to [FileProfile](class_mip_fileprofile.md).",
         "\n  ",
         "**Returns**: [Observer](class_mip_fileprofile_observer.md) which receieves notifications of events related to [FileProfile](class_mip_fileprofile.md)",
         "  ",
         "### ApplicationInfo",
         "Gets info regarding application that is consuming the SDK.",
         "\n  ",
         "**Returns**: Info regarding application that is consuming the SDK",
         "  ",
         "### GetSkipTelemetryInit",
         "Gets whether or not telemetry initialization should be skipped.",
         "\n  ",
         "**Returns**: Whether or not telemetry initialization should be skipped",
         "  ",
         "### SetSkipTelemetryInit",
         "Disables telemetry initialization.",
         "This should not normally be called by client applications, rather it is used by File SDK (which already initializes telemetry) to prevent duplicate initialization",
         "  ",
         "### OptOutTelemetry",
         "Opts out of all telemetry gathering.",
         "  ",
         "### IsTelemetryOptedOut",
         "Gets whether or not telemetry gathering should be disabled.",
         "\n  ",
         "**Returns**: Whether or not telemetry gathering should be disabled",
         "  ",
         "### SetSessionId",
         "Sets the session id.",
         "\nParameters:  ",
         "* **sessionId**: Session id which will be used to correlate logs/telemetry",
         "\n",
         "  ",
         "### GetSessionId",
         "Gets the session id.",
         "\n  ",
         "**Returns**: Session id which will be used to correlate logs/telemetry"
      ],
      "declarations": [
         {
            "declName": "Settings",
            "declType": " inline Settings(const std::string& path, bool useInMemoryStorage, std::shared_ptr<AuthDelegate> authDelegate, std::shared_ptr<Observer> observer, const ApplicationInfo& applicationInfo) ",
            "declaration": "public Settings(const std::string& path, bool useInMemoryStorage, std::shared_ptr<AuthDelegate> authDelegate, std::shared_ptr<Observer> observer, const ApplicationInfo& applicationInfo) "
         },
         {
            "declName": "GetPath",
            "declType": " public inline const std::string& GetPath() const ",
            "declaration": " public const std::string& GetPath() const "
         },
         {
            "declName": "GetUseInMemoryStorage",
            "declType": " public inline bool GetUseInMemoryStorage() const ",
            "declaration": " public bool GetUseInMemoryStorage() const "
         },
         {
            "declName": "GetAuthDelegate",
            "declType": " inline std::shared_ptr<AuthDelegate> GetAuthDelegate() const ",
            "declaration": "public std::shared_ptr<AuthDelegate> GetAuthDelegate() const "
         },
         {
            "declName": "GetObserver",
            "declType": " inline std::shared_ptr<Observer> GetObserver() const ",
            "declaration": "public std::shared_ptr<Observer> GetObserver() const "
         },
         {
            "declName": "GetApplicationInfo",
            "declType": " public inline const ApplicationInfo GetApplicationInfo() const ",
            "declaration": " public const ApplicationInfo GetApplicationInfo() const "
         },
         {
            "declName": "GetSkipTelemetryInit",
            "declType": " public inline bool GetSkipTelemetryInit() const ",
            "declaration": " public bool GetSkipTelemetryInit() const "
         },
         {
            "declName": "SetSkipTelemetryInit",
            "declType": " public inline void SetSkipTelemetryInit() ",
            "declaration": " public void SetSkipTelemetryInit() "
         },
         {
            "declName": "OptOutTelemetry",
            "declType": " public inline void OptOutTelemetry() ",
            "declaration": " public void OptOutTelemetry() "
         },
         {
            "declName": "IsTelemetryOptedOut",
            "declType": " public inline bool IsTelemetryOptedOut() const ",
            "declaration": " public bool IsTelemetryOptedOut() const "
         },
         {
            "declName": "SetSessionId",
            "declType": " public inline void SetSessionId(const std::string& sessionId) ",
            "declaration": " public void SetSessionId(const std::string& sessionId) "
         },
         {
            "declName": "GetSessionId",
            "declType": " public inline const std::string& GetSessionId() const ",
            "declaration": " public const std::string& GetSessionId() const "
         }
      ],
      "fileName": "class_mip_fileprofile_settings.md"
   },
   {
      "lines": [
         "# class mip::Profile::Settings ",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "public Settings(const std::string& path, bool useInMemoryStorage, const std::shared_ptr<AuthDelegate>& authDelegate, const std::shared_ptr<Profile::Observer>& observer, const ApplicationInfo& applicationInfo)  |  Interface for configuring the profile.",
         " public const std::string& GetPath() const  |  Get the path to the stored state.",
         " public bool GetUseInMemoryStorage() const  |  Get the Use In Memory Storage flag.",
         "public const std::shared_ptr<AuthDelegate>& GetAuthDelegate() const  |  Get the Auth Delegate.",
         "public const std::shared_ptr<Profile::Observer>& GetObserver() const  |  Get the event observer.",
         " public const ApplicationInfo GetApplicationInfo() const  |  Get the application info.",
         " public void OptOutTelemetry()  |  Opts out of all telemetry gathering.",
         " public bool IsTelemetryOptedOut() const  |  Gets whether or not telemetry gathering should be disabled.",
         "  ",
         "## Members",
         "  ",
         "### Settings",
         "Interface for configuring the profile.",
         "\nParameters:  ",
         "* **path**: The path to a directory in which the sdk will store the profile state. ",
         "\n",
         "* **useInMemoryStorage**: A flag indicating whether or not state should be stored on disk. ",
         "\n",
         "* **authDelegate**: The authentication delegate used by the SDK to acquire authentication tokens. ",
         "\n",
         "* **observer**: A class implementing the [Profile::Observer](class_mip_profile_observer.md) interface. Can be nullptr. ",
         "\n",
         "* **applicationInfo**: The application identifiers used for service access.",
         "\n",
         "  ",
         "### GetPath",
         "Get the path to the stored state.",
         "\n  ",
         "**Returns**: Path to stored state.",
         "  ",
         "### GetUseInMemoryStorage",
         "Get the Use In Memory Storage flag.",
         "\n  ",
         "**Returns**: True if use in memory is set else false.",
         "  ",
         "### GetAuthDelegate",
         "Get the Auth Delegate.",
         "\n  ",
         "**Returns**: The Auth Delegate.",
         "  ",
         "### Profile::Observer",
         "Get the event observer.",
         "\n  ",
         "**Returns**: The event observer.",
         "  ",
         "### ApplicationInfo",
         "Get the application info.",
         "\n  ",
         "**Returns**: The application info.",
         "  ",
         "### OptOutTelemetry",
         "Opts out of all telemetry gathering.",
         "  ",
         "### IsTelemetryOptedOut",
         "Gets whether or not telemetry gathering should be disabled.",
         "\n  ",
         "**Returns**: Whether or not telemetry gathering should be disabled"
      ],
      "declarations": [
         {
            "declName": "Settings",
            "declType": " inline Settings(const std::string& path, bool useInMemoryStorage, const std::shared_ptr<AuthDelegate>& authDelegate, const std::shared_ptr<Profile::Observer>& observer, const ApplicationInfo& applicationInfo) ",
            "declaration": "public Settings(const std::string& path, bool useInMemoryStorage, const std::shared_ptr<AuthDelegate>& authDelegate, const std::shared_ptr<Profile::Observer>& observer, const ApplicationInfo& applicationInfo) "
         },
         {
            "declName": "GetPath",
            "declType": " public inline const std::string& GetPath() const ",
            "declaration": " public const std::string& GetPath() const "
         },
         {
            "declName": "GetUseInMemoryStorage",
            "declType": " public inline bool GetUseInMemoryStorage() const ",
            "declaration": " public bool GetUseInMemoryStorage() const "
         },
         {
            "declName": "GetAuthDelegate",
            "declType": " inline const std::shared_ptr<AuthDelegate>& GetAuthDelegate() const ",
            "declaration": "public const std::shared_ptr<AuthDelegate>& GetAuthDelegate() const "
         },
         {
            "declName": "GetObserver",
            "declType": " inline const std::shared_ptr<Profile::Observer>& GetObserver() const ",
            "declaration": "public const std::shared_ptr<Profile::Observer>& GetObserver() const "
         },
         {
            "declName": "GetApplicationInfo",
            "declType": " public inline const ApplicationInfo GetApplicationInfo() const ",
            "declaration": " public const ApplicationInfo GetApplicationInfo() const "
         },
         {
            "declName": "OptOutTelemetry",
            "declType": " public inline void OptOutTelemetry() ",
            "declaration": " public void OptOutTelemetry() "
         },
         {
            "declName": "IsTelemetryOptedOut",
            "declType": " public inline bool IsTelemetryOptedOut() const ",
            "declaration": " public bool IsTelemetryOptedOut() const "
         }
      ],
      "fileName": "class_mip_profile_settings.md"
   },
   {
      "lines": [
         "# class mip::ProtectionProfile::Settings ",
         "[Settings](class_mip_protectionprofile_settings.md) used by [ProtectionProfile](class_mip_protectionprofile.md) during its creation and throughout its lifetime.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         "public Settings(const std::string& path, const std::shared_ptr<ProtectionProfile::Observer>& observer, const ApplicationInfo& applicationInfo)  |  [ProtectionProfile::Settings](class_mip_protectionprofile_settings.md) constructor.",
         " public const std::string& GetPath() const  |  Gets the path under which logging, telemetry, and other protection collateral is stored.",
         "public const std::shared_ptr<ProtectionProfile::Observer>& GetObserver() const  |  Gets the observer which receieves notifications of events related to [ProtectionProfile](class_mip_protectionprofile.md).",
         " public const ApplicationInfo& GetApplicationInfo() const  |  Gets info regarding application which is consuming the protection SDK.",
         " public void OptOutTelemetry()  |  Opts out of all telemetry gathering.",
         " public bool IsTelemetryOptedOut() const  |  Gets whether or not telemetry gathering should be disabled.",
         " public bool GetSkipTelemetryInit() const  |  Gets whether or not telemetry initialization should be skipped.",
         " public void SetSkipTelemetryInit()  |  Disables telemetry initialization.",
         " public void SetSessionId(const std::string& sessionId)  |  Sets the session id.",
         " public const std::string& GetSessionId() const  |  Gets the session id.",
         "  ",
         "## Members",
         "  ",
         "### Settings",
         "[ProtectionProfile::Settings](class_mip_protectionprofile_settings.md) constructor.",
         "\nParameters:  ",
         "* **path**: File path under which logging, telemetry, and other protection collateral is stored ",
         "\n",
         "* **observer**: [Observer](class_mip_protectionprofile_observer.md) instance which will receive notifications of events related to [ProtectionProfile](class_mip_protectionprofile.md)",
         "\n",
         "* **applicationInfo**: Info regarding application which is consuming the protection SDK",
         "\n",
         "  ",
         "### GetPath",
         "Gets the path under which logging, telemetry, and other protection collateral is stored.",
         "\n  ",
         "**Returns**: Path under which logging, telemetry, and other protection collateral is stored",
         "  ",
         "### ProtectionProfile::Observer",
         "Gets the observer which receieves notifications of events related to [ProtectionProfile](class_mip_protectionprofile.md).",
         "\n  ",
         "**Returns**: [Observer](class_mip_protectionprofile_observer.md) which receieves notifications of events related to [ProtectionProfile](class_mip_protectionprofile.md)",
         "  ",
         "### ApplicationInfo",
         "Gets info regarding application which is consuming the protection SDK.",
         "\n  ",
         "**Returns**: Info regarding application which is consuming the protection SDK",
         "  ",
         "### OptOutTelemetry",
         "Opts out of all telemetry gathering.",
         "  ",
         "### IsTelemetryOptedOut",
         "Gets whether or not telemetry gathering should be disabled.",
         "\n  ",
         "**Returns**: Whether or not telemetry gathering should be disabled",
         "  ",
         "### GetSkipTelemetryInit",
         "Gets whether or not telemetry initialization should be skipped.",
         "\n  ",
         "**Returns**: Whether or not telemetry initialization should be skipped",
         "  ",
         "### SetSkipTelemetryInit",
         "Disables telemetry initialization.",
         "This should not normally be called by client applications, rather it is used by File SDK (which already initializes telemetry) to prevent duplicate initialization",
         "  ",
         "### SetSessionId",
         "Sets the session id.",
         "\nParameters:  ",
         "* **sessionId**: Session id which will be used to correlate logs/telemetry",
         "\n",
         "  ",
         "### GetSessionId",
         "Gets the session id.",
         "\n  ",
         "**Returns**: Session id which will be used to correlate logs/telemetry"
      ],
      "declarations": [
         {
            "declName": "Settings",
            "declType": " inline Settings(const std::string& path, const std::shared_ptr<ProtectionProfile::Observer>& observer, const ApplicationInfo& applicationInfo) ",
            "declaration": "public Settings(const std::string& path, const std::shared_ptr<ProtectionProfile::Observer>& observer, const ApplicationInfo& applicationInfo) "
         },
         {
            "declName": "GetPath",
            "declType": " public inline const std::string& GetPath() const ",
            "declaration": " public const std::string& GetPath() const "
         },
         {
            "declName": "GetObserver",
            "declType": " inline const std::shared_ptr<ProtectionProfile::Observer>& GetObserver() const ",
            "declaration": "public const std::shared_ptr<ProtectionProfile::Observer>& GetObserver() const "
         },
         {
            "declName": "GetApplicationInfo",
            "declType": " public inline const ApplicationInfo& GetApplicationInfo() const ",
            "declaration": " public const ApplicationInfo& GetApplicationInfo() const "
         },
         {
            "declName": "OptOutTelemetry",
            "declType": " public inline void OptOutTelemetry() ",
            "declaration": " public void OptOutTelemetry() "
         },
         {
            "declName": "IsTelemetryOptedOut",
            "declType": " public inline bool IsTelemetryOptedOut() const ",
            "declaration": " public bool IsTelemetryOptedOut() const "
         },
         {
            "declName": "GetSkipTelemetryInit",
            "declType": " public inline bool GetSkipTelemetryInit() const ",
            "declaration": " public bool GetSkipTelemetryInit() const "
         },
         {
            "declName": "SetSkipTelemetryInit",
            "declType": " public inline void SetSkipTelemetryInit() ",
            "declaration": " public void SetSkipTelemetryInit() "
         },
         {
            "declName": "SetSessionId",
            "declType": " public inline void SetSessionId(const std::string& sessionId) ",
            "declaration": " public void SetSessionId(const std::string& sessionId) "
         },
         {
            "declName": "GetSessionId",
            "declType": " public inline const std::string& GetSessionId() const ",
            "declaration": " public const std::string& GetSessionId() const "
         }
      ],
      "fileName": "class_mip_protectionprofile_settings.md"
   },
   {
      "lines": [
         "# struct ApplicationInfo ",
         "Application identifier as set in the aad portal.",
         "  ",
         "## Summary",
         " Members                        | Descriptions                                ",
         "--------------------------------|---------------------------------------------",
         " public std::string applicationId  | _Not yet documented._",
         " public std::string friendlyName  | _Not yet documented._",
         "  ",
         "## Members",
         "  ",
         "### applicationId",
         "_Not documented yet._\n",
         "  ",
         "### friendlyName"
      ],
      "declarations": [
         {
            "declName": "applicationId",
            "declType": " public std::string applicationId ",
            "declaration": " public std::string applicationId "
         },
         {
            "declName": "friendlyName",
            "declType": " public std::string friendlyName ",
            "declaration": " public std::string friendlyName "
         }
      ],
      "fileName": "struct_applicationinfo.md"
   }
]